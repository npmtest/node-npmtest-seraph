{"/home/travis/build/npmtest/node-npmtest-seraph/test.js":"/* istanbul instrument in package npmtest_seraph */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-seraph/lib.npmtest_seraph.js":"/* istanbul instrument in package npmtest_seraph */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_seraph = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_seraph = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-seraph/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-seraph && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_seraph */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_seraph\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_seraph.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_seraph.rollup.js'] =\n            local.assetsDict['/assets.npmtest_seraph.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_seraph.__dirname + '/lib.npmtest_seraph.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/lib/seraph.js":"var naan = require('naan');\nvar async = require('async');\nvar request = require('request');\nvar _ = require('underscore');\nvar assert = require('assert');\nvar util = require('util');\nvar Core = require('seraph-core');\n\n// Bind all functions of an object to a context (recursively)\nvar bindAllTo = function(context, all) {\n  return Object.keys(all).reduce(function(bound, key) {\n    if (typeof all[key] == 'object') bound[key] = bindAllTo(context, all[key]);\n    else if (typeof all[key] == 'function') bound[key] = all[key].bind(context);\n    else bound[key] = all[key];\n    return bound;\n  }, {});\n}\n\n// Polyfill Object.setPrototypeOf for older node versions.\nvar setPrototypeOf = Object.setPrototypeOf || function setPrototypeOfPolyfill(obj, proto) { obj.__proto__ = proto; };\n\nfunction Seraph(options) {\n  if (options.bolt) return require('./bolt/seraph')(options);\n  var core = new Core(options);\n\n  setPrototypeOf(Object.getPrototypeOf(this), core);\n  this.options = core.options;\n\n  _.bindAll.apply(_, [this].concat(_.functions(this)));\n\n  this.node = bindAllTo(this, require('./node'));\n  this.relationship = this.rel = bindAllTo(this, require('./relationship'));\n  this.index = bindAllTo(this, require('./index'));\n  this.constraints = bindAllTo(this, require('./constraints'));\n  var legacyindexGeneric = bindAllTo(this, require('./legacyindex'));\n\n\n  // Alias & curry seraph.index on seraph.node & seraph.rel\n  this.node.legacyindex = naan.curry(legacyindexGeneric.add, 'node');\n  this.rel.legacyindex = naan.curry(legacyindexGeneric.add, 'relationship');\n  naan.ecrock(this.node.legacyindex, legacyindexGeneric, naan.curry, 'node');\n  naan.ecrock(this.rel.legacyindex, legacyindexGeneric, naan.curry, 'relationship');\n\n  _.extend(this, this.node);\n}\n\n\n// returns a new batch if the context was not already that of a batch - prevents\n// batch nesting which can break intra-batch referencing\nSeraph.prototype._safeBatch = function() {\n  return this.isBatch ? this : this.batch();\n};\n\n// similarly, this takes a BatchSeraph and only commits it if the calling context \n// is not that of a batch.\nSeraph.prototype._safeBatchCommit = function(txn, callback) {\n  if (this.isBatch) {\n    if (callback) this.commitCallbacks.push(callback);\n  } else {\n    txn.commit(callback);\n  }\n};\n\n/**\n * If `obj` is an object, return the value of key <options.id>. Otherwise,\n * return `obj`.\n *\n * If `requireData` is truthy, `obj` must be an object, otherwise undefined is\n * returned.\n */\nSeraph.prototype._getId = function(obj, requireData) {\n  var id;\n  if (requireData) {\n    id = typeof obj == 'object' ? obj[this.options.id] : undefined;\n  } else if (this._isBatchId(obj)) {\n    return obj;\n  } else {\n    id = typeof obj == 'object' ? obj[this.options.id] : obj;\n  }\n\n  if (id != null) id = parseInt(id, 10);\n  return id;\n};\n\nSeraph.prototype._isValidId = function(id) {\n  return !isNaN(parseInt(id, 10)) || this._isBatchId(id);\n};\n\n/**\n * Take the end off a url and parse it as an int\n */\nSeraph.prototype._extractId = function(location) {\n  var matches = location.match(/\\/(\\d+)$/);\n  if (!matches) {\n    return null;\n  }\n\n  return parseInt(matches[1], 10);\n};\n\n/**\n * Infer whether or not the given object is a node\n */\nSeraph.nodeFlags = [ \n  'outgoing_relationships',\n  'incoming_relationships',\n  'all_relationships',\n  'data',\n  'properties',\n  'self'\n];\nSeraph.prototype._isNode = function(node) {\n  if (!node || typeof node !== 'object') {\n    return false;\n  }\n\n  var inNode = node.hasOwnProperty.bind(node);\n  return Seraph.nodeFlags.every(inNode) && \n         typeof node.data === 'object';\n};\n\n/**\n * Infer whether or not the given object is a relationship\n */\nSeraph.relationshipFlags = [\n  'start',\n  'data',\n  'self',\n  'properties',\n  'end'\n];\nSeraph.prototype._isRelationship = function(rel) {\n  if (!rel || typeof rel !== 'object') {\n    return false;\n  }\n\n  var inRelationship = rel.hasOwnProperty.bind(rel);\n  return Seraph.relationshipFlags.every(inRelationship) &&\n         typeof rel.data === 'object';\n};\n\nSeraph.prototype._isBatchId = function(id) {\n  return this.isBatch && typeof id == 'string' && id.match(/^{\\d+}$/);\n};\n\nSeraph.prototype._nodeRoot = function(id) {\n  return this._isBatchId(id) ? id : 'node/' + id;\n};\n\nSeraph.prototype._relRoot = function(id) {\n  return this._isBatchId(id) ? id : 'relationship/' + id;\n};\n\n/**\n * Returns the url to an entity given an id\n */\nSeraph.prototype._location = function(type, id) {\n  if (this._isBatchId(id)) return id;\n  return util.format('%s%s/%s/%d',\n                     this.options.server, this.options.endpoint, type, id);\n};\n\n/**\n * Create a relationship object from the given relationship data returned from\n * the neo4j server\n */\nSeraph.prototype._createRelationshipObject = function(relationshipData) {\n  var relationshipObj = { \n    start: this._extractId(relationshipData.start),\n    end: this._extractId(relationshipData.end),\n    type: relationshipData.type,\n    properties: relationshipData.data\n  };\n\n  relationshipObj[this.options.id] = this._extractId(relationshipData.self);\n\n  return relationshipObj;\n};\n\n/** \n * Create a node object from the given node data return from the neo4j server\n */\nSeraph.prototype._createNodeObject = function(nodeData) {\n  var nodeObj = nodeData.data || {};\n  nodeObj[this.options.id] = this._extractId(nodeData.self);\n\n  return nodeObj;\n};\n\n  /**\n   * Perform a cypher query. Maps to POST cypher\n   */\nSeraph.prototype.queryRaw = function(query, params, callback) {\n  if (typeof query !== 'string') {\n    return callback(new Error('Invalid Query'));\n  }\n  if (typeof params !== 'object') {\n    if (typeof params === 'function') {\n      callback = params;\n    }\n    params = {};\n  }\n\n  query = { statements: [ {\n    statement: query,\n    parameters: params,\n    resultDataContents: ['REST']\n  } ] } ;\n  var op = this.operation('transaction/commit', query);\n  this.call(op, function(err, result) {\n    if (err || result.errors[0]) {\n      callback(err || result.errors[0]);\n    } else {\n      result = result.results[0];\n      result.data = result.data.map(function(row) { return row.rest });\n      callback(null, result);\n    }\n  });\n};\n\nSeraph.prototype._parseQueryResult = function(result) {\n  var self = this;\n  var namedResults = result.data.map(function(row) {\n    return result.columns.reduce(function(rowObj, columnName, columnIndex) {\n      var resultItem = row[columnIndex];\n      function extractAttributes(item) {\n        if (self._isNode(item)) {\n          return self._createNodeObject(item);\n        } else if (self._isRelationship(item)) {\n          return self._createRelationshipObject(item);\n        } else if (Array.isArray(item)) {\n          return item.map(extractAttributes);\n        } else if (item === Object(item)) {\n          return _.mapObject(item, extractAttributes);\n        } else {\n          return item;\n        }\n      }\n\n      rowObj[columnName] = extractAttributes(resultItem);\n      \n      return rowObj;\n    }, {});\n  });\n\n  if (namedResults.length > 0) {\n    var resultsAreObjects = typeof namedResults[0][result.columns[0]] == 'object';\n    if (result.columns.length === 1 && resultsAreObjects) {\n      namedResults = namedResults.map(function(namedResult) {\n        return namedResult[result.columns[0]];\n      });\n    }\n  }\n\n  return namedResults;\n}\n\n/**\n * Perform a cypher query and map the columns and results together.\n */\nSeraph.prototype.query = function(query, params, callback) {\n  if (typeof params !== 'object') {\n    if (typeof params === 'function') {\n      callback = params;\n    }\n    params = {};\n  }\n  \n  var self = this;\n  this.queryRaw(query, params, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    \n    callback(null, self._parseQueryResult(result));\n  });\n};\n\nvar globalCounter = 0;\nfunction wrapForBatchFormat(id) { return '{' + id + '}' };\nfunction BatchSeraphId(id, refersTo, batch) {\n  if (Array.isArray(refersTo)) {\n    refersTo = refersTo.map(wrapForBatchFormat);\n    refersTo.forEach(function(id, index) {\n      this[index] = id;\n    }.bind(this));\n  } else {\n    refersTo = wrapForBatchFormat(refersTo);\n  }\n\n  this.id = id;\n  this.refersTo = refersTo;\n  this.batch = batch;\n}\nObject.defineProperty(BatchSeraphId.prototype, 'valueOf', {\n  enumerable: false, configurable: false, writable: false,\n  value: function() { return this.id }\n});\nObject.defineProperty(BatchSeraphId.prototype, 'toString', {\n  enumerable: false, configurable: false, writable: false,\n  value: function() { return this.id } \n});\n\nfunction BatchSeraph(parentSeraph) {\n  var self = this;\n  var uniq = Date.now() + ++globalCounter;\n\n  function isBatchId(id) {\n    return id instanceof BatchSeraphId && id.batch == uniq;\n  };\n\n  function createId(id, refersTo) {\n    return new BatchSeraphId(id, refersTo, uniq);\n  };\n\n  function transformBatchArgs(args) {\n    return args.map(function(arg) {\n      if (Array.isArray(arg)) return transformBatchArgs(arg);\n      return isBatchId(arg) ? arg.refersTo : arg;\n    });\n  };\n\n  function wrapFunctions(parent, target) {\n    var derived = target || {};\n\n    // parent could be undefined or null, so skip walking such\n    parent && Object.keys(parent).forEach(function(key) {\n      if (key == 'agent') return;\n\n      var valueType = typeof parent[key];\n\n      if (valueType === 'function') {\n        derived[key] = wrapFunction(parent[key]);\n\n        if (Object.keys(parent[key]).length > 0) {\n          derived[key] = wrapFunctions(parent[key], derived[key]);\n        }\n      } else if (valueType === 'object') {\n        derived[key] = wrapFunctions(parent[key]);\n      } else {\n        derived[key] = parent[key];\n      }\n    });\n    return derived;\n  }\n\n  function wrapFunction(fn) {\n    fn = naan.rcurry(fn, function(err, result) {\n      if (err && !self.error) self.error = err;\n      self.results.push(result);\n      var cb = self.callbacks.shift();\n      if (cb) cb(err, result);\n    });\n    return function() {\n      self.operationQueueStack.unshift([]);\n\n      var args = [].slice.apply(arguments);\n\n      if (args.length > 1 && typeof args[args.length - 1] == 'function') {\n        self.callbacks.push(args.pop());\n      } else {\n        self.callbacks.push(null);\n      }\n\n      args = transformBatchArgs(args);\n\n      // Context does not matter because all functions are bound upon seraph init\n      fn.apply(undefined, args);\n\n      var operationIds = _.pluck(self.operationQueueStack[0], 'id');\n      self.operationQueueStack.shift();\n\n      var operationId = operationIds.length \n        ? operationIds[0] - self.operationOffset : undefined;\n\n      if (operationIds.length > 1) {\n        self.operationOffset += operationIds.length - 1;\n        operationId = createId(operationId, operationIds);\n      } else if (operationId != null) {\n        operationId = createId(operationId, operationIds[0]);\n      }\n\n      return operationId;\n    };\n  }\n\n  this.super = new Seraph(parentSeraph.options);\n  this.__proto__ = wrapFunctions(this.super);\n  this.isBatch = this.super.isBatch = true;\n  this.batch = undefined; // disabled nesting.\n  this.processors = [];\n  this.operations = [];\n  this.callbacks = [];\n  this.results = [];\n  this.operationOffset = 0;\n  this.operationQueueStack = [];\n  this.commitCallbacks = [];\n\n  this.super.call = function(operation, processor) {\n    operation.id = self.operations.length;\n    if (!operation.body) delete operation.body;\n\n    self.operations.push(operation);\n    self.processors.push(processor.bind(self.super));\n    self.operationQueueStack[0].push(operation);\n  };\n  \n  function handleSelfError(error) {\n    self.commitCallbacks.forEach(function(callback) {\n      callback(error);\n    });\n  }\n  \n  this.commit = function(callback) {\n    if (callback) self.commitCallbacks.push(callback);\n    if (self.error) return handleSelfError(self.error)\n    var op = parentSeraph.operation('batch', 'POST', self.operations);\n    parentSeraph.call(op, function(err, results) {\n      if (err) {\n        while (self.callbacks.length) {\n          var cb = self.callbacks.shift();\n          if (cb) cb(err);\n        }\n        return self.commitCallbacks.forEach(function(callback) {\n          callback(err);\n        });\n      }\n\n      results.forEach(function(result) {\n        self.processors.shift()(null, result.body || {}, result.location);\n      });\n\n      if (self.error) return handleSelfError(self.error)\n      \n      self.commitCallbacks.forEach(function(callback) {\n        callback(null, self.results);\n      });\n    });\n  };\n}\n\nSeraph.prototype.isBatch = false;\n\nSeraph.prototype.batch = function(operations, callback) {\n  if (!arguments.length) return new BatchSeraph(this);\n\n  var batchSeraph = new BatchSeraph(this);\n  operations(batchSeraph);\n  batchSeraph.commit(callback);\n};\n\nmodule.exports = function(options) {\n  if (options && options.thunkify) {\n    delete options.thunkify;\n    return require('../co')(options);\n  }\n  return new Seraph(options);\n};\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/bolt.js":"module.exports = require('lib/bolt/seraph');\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/co.js":"var seraph = require('./lib/seraph');\nvar thunkify = require('thunkify');\nvar excludes = [\n  'batch',\n  'operation'\n];\n\nmodule.exports = function(opts) {\n  var db = seraph(opts);\n  return function wrapObject(obj) {\n    var copy = {};\n    Object.keys(obj).forEach(function(key) {\n      if (typeof obj[key] == 'function' && excludes.indexOf(key) == -1 && key[0] != '_') {\n        copy[key] = thunkify(obj[key]);\n      } else if (typeof obj[key] == 'object') {\n        copy[key] = wrapObject(obj[key]);\n      } else {\n        copy[key] = obj[key];\n      }\n    }); \n    return copy;\n  }(db);\n};\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/lib/constraints.js":"var async = require('async');\nvar naan = require('naan');\nvar _ = require('underscore');\nvar util = require('util');\n\nexports.uniqueness = {};\n\nexports.uniqueness.create = function(label, keys, callback) {\n  if (!Array.isArray(keys)) keys = [keys];\n\n  label = encodeURIComponent(label);\n  var body = { property_keys: keys };\n\n  var endpoint = util.format('schema/constraint/%s/uniqueness', label);\n  var op = this.operation(endpoint, 'POST', body);\n  this.call(op, function(err, index) {\n    if (err) callback(err);\n    else callback(null, index);\n  });\n};\n\nexports.uniqueness.createIfNone = function(label, keys, callback) {\n  var self = this;\n  exports.uniqueness.list.call(self, label, keys, function(err, constraints) {\n    if (err) {\n      if (err.statusCode != 404) return callback(err);\n    } else if (constraints.length > 0) return callback(null, constraints[0]);\n    // Seems like sometimes if this is being called very early in neo4j's init\n    // phase, the list command doesn't return a constraint, but the following\n    // calls sends back a 409. So we check for that, and don't send that error\n    // through.\n    exports.uniqueness.create.call(self, label, keys, function(err, constraint) {\n      if (err) {\n        if (err.statusCode == 409) {\n          // in this edgecase there's no way really for us to get the constraint\n          // object, so send back without (for now). hopefully there's a better\n          // way to handle this in the future.\n          return callback();\n        } else {\n          return callback(err);\n        }\n      }\n\n      callback(null, constraint);\n    });\n  });\n};\n\nexports.uniqueness.list = function(label, key, callback) {\n  if (typeof key == 'function') {\n    callback = key;\n    key = null;\n  }\n\n  label = encodeURIComponent(label);\n  var endpoint = util.format('schema/constraint/%s/uniqueness', label);\n\n  if (key) {\n    key = encodeURIComponent(key);\n    endpoint += '/' + key;\n  }\n\n  var op = this.operation(endpoint, 'GET');\n  this.call(op, function(err, constraints) {\n    if (err) callback(err);\n    else callback(null, constraints);\n  });\n};\n\nexports.uniqueness.drop = function(label, key, callback) {\n  label = encodeURIComponent(label);\n  key = encodeURIComponent(key);\n  var endpoint = util.format('schema/constraint/%s/uniqueness/%s', label, key);\n  var op = this.operation(endpoint, 'DELETE');\n  this.call(op, function(err) {\n    if (err) callback(err);\n    else callback();\n  });\n};\n\nexports.list = function(label, callback) {\n  if (typeof label == 'function') {\n    callback = label;\n    label = null; \n  }\n\n  var endpoint = 'schema/constraint';\n\n  if (label) endpoint += '/' + encodeURIComponent(label);\n\n  var op = this.operation(endpoint, 'GET');\n  this.call(op, function(err, constraints) {\n    if (err) callback(err);\n    else callback(null, constraints);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/lib/index.js":"var async = require('async');\nvar naan = require('naan');\nvar _ = require('underscore');\nvar util = require('util');\n\n// although it looks like this will support compound keys, neo4j-2 doesn't yet, \n// so attempting to create one will just give you an error from neo4j.\nexports.create = function(label, keys, callback) {\n  if (!Array.isArray(keys)) keys = [keys];\n\n  label = encodeURIComponent(label);\n  var body = { property_keys: keys };\n\n  var endpoint = util.format('schema/index/%s', label);\n  var op = this.operation(endpoint, 'POST', body);\n  this.call(op, function(err, index) {\n    if (err) callback(err);\n    else callback(null, index);\n  });\n};\n\n// this will need to be updated when compound keys are supported\nexports.createIfNone = function(label, keys, callback) {\n  var self = this;\n  exports.create.call(self, label, keys, function(err, index) {\n    if (!err) return callback(null, index);\n    if (err.statusCode != 409) return callback(err);\n    exports.list.call(self, label, function(err, indexes) {\n      if (err) return callback(err);\n      var index = indexes.filter(function(index) {\n        return index.property_keys[0] == keys;\n      });\n      callback(null, index[0]);\n    });\n  });\n};\n\nexports.list = function(label, callback) {\n  label = encodeURIComponent(label);\n  var endpoint = util.format('schema/index/%s', label);\n  var op = this.operation(endpoint, 'GET');\n  this.call(op, function(err, indexes) {\n    if (err) callback(err);\n    else callback(null, indexes);\n  });\n};\n\nexports.drop = function(label, key, callback) {\n  label = encodeURIComponent(label);\n  key = encodeURIComponent(key);\n  var endpoint = util.format('schema/index/%s/%s', label, key);\n  var op = this.operation(endpoint, 'DELETE');\n  this.call(op, function(err) {\n    if (err) callback(err);\n    else callback();\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/lib/legacyindex.js":"var async = require('async');\nvar naan = require('naan');\nvar _ = require('underscore');\nvar util = require('util');\n\nfunction isValidType(type, callback) {\n  if (type !== 'node' && type !== 'relationship') {\n    callback(new Error(\"Invalid index type (should be 'node' or \" +\n          \"'relationship'.\"));\n    return false;\n  }\n  return true;\n}\n\nfunction saveUnique(mode) {\n  return function() {\n    var args = [].slice.call(arguments);\n    var type = args.shift();\n    args.push(mode);\n    if (type == 'node') return saveUniqueNode.apply(this, args);\n    else return saveUniqueRel.apply(this, args);\n  };\n};\n\nfunction saveUniqueNode(node, index, key, value, callback, mode) {\n  var self = this;\n\n  var request = {\n    key: key,\n    value: value,\n    properties: node\n  };\n\n  var endpoint = util.format('index/node/%s?uniqueness=%s', index, mode);\n  var op = this.operation(endpoint, 'POST', request);\n  this.call(op, function(err, node) {\n    if (err) return callback(err);\n    callback(null, this._createNodeObject(node));\n  });\n};\n\nfunction saveUniqueRel(start, rel, end, props, idx, key, value, cb, mode) {\n  var self = this;\n  if (typeof props == 'string') {\n    mode = cb;\n    cb = value;\n    value = key;\n    key = idx;\n    idx = props;\n    props = undefined;\n  }\n\n  start = this._getId(start);\n  end = this._getId(end);\n\n  if (!this._isValidId(start) || !this._isValidId(end)) {\n    return callback(new Error(\"Invalid ID\"));\n  }\n\n  var request = {\n    key: key,\n    value: value,\n    start: this._location('node', start),\n    end: this._location('node', end),\n    type: rel\n  };\n\n  if (props) request.properties = props;\n\n  var endpoint = util.format('index/relationship/%s?uniqueness=%s', idx, mode);\n  var op = this.operation(endpoint, 'POST', request);\n  this.call(op, function(err, rel) {\n    if (err) return cb(err);\n    cb(null, self._createRelationshipObject(rel));\n  });\n};\n\nvar indexModule = module.exports = {\n  create: function(type, name, config, callback) {\n    if (typeof name === 'function') {\n      callback = name;\n      name = type;\n      type = 'node';\n      config = null;\n    } else if (typeof config === 'function') {\n      callback = config;\n      if (typeof name === 'object' && !Array.isArray(name)) {\n        config = name;\n        name = type;\n        type = 'node';\n      } else {\n        config = null;\n      }\n    } \n\n    if (Array.isArray(name)) {\n      var txn = this._safeBatch();\n      var indexer = naan.ncurry(txn[type].legacyindex.create, config, 1);\n      async.map(name, indexer, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    if (!isValidType(type, callback)) {\n      return;\n    }\n\n    var request = { name: name };\n    if (config != null) {\n      request.config = config;\n    }\n\n    var endpoint = util.format('index/%s', type);\n    var op = this.operation(endpoint, 'POST', request);\n    this.call(op, function(err) {\n      callback(err);\n    });\n  },\n\n  add: function(type, indexName, obj, key, value, callback) {\n    if (typeof value === 'function') {\n      callback = value;\n      value = key;\n      key = obj;\n      obj = indexName;\n      indexName = type;\n      type = 'node';\n    }\n    \n    if (Array.isArray(obj)) {\n      var txn = this._safeBatch();\n      var args = [indexName, key, value];\n      var indexer = naan.ecurry(txn[type].legacyindex.add, args, [0, 2, 3]);\n      async.map(obj, indexer, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    if (!isValidType(type, callback)) {\n      return;\n    }\n\n    var id = this._getId(obj);\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n    var location = this._location(type, id);\n\n    var request = {\n      uri: location,\n      key: key,\n      value: value\n    };\n\n    indexName = encodeURIComponent(indexName);\n\n    var endpoint = util.format('index/%s/%s', type, indexName);\n    var op = this.operation(endpoint, 'POST', request);\n    this.call(op, function(err) {\n      callback(err);\n    });\n  },\n\n  readAsList: function(type, indexName, key, value, callback) {\n    if (typeof value === 'function') {\n      callback = value;\n      value = key;\n      key = indexName;\n      indexName = type;\n      type = 'node';\n    }\n\n    if (!isValidType(type, callback)) {\n      return;\n    }\n\n    indexName = encodeURIComponent(indexName);\n    value = encodeURIComponent(value); \n    key = encodeURIComponent(key);\n\n    var ep = util.format('index/%s/%s/%s/%s', type, indexName, key, value);\n    var op = this.operation(ep, 'GET');\n    var self = this;\n    this.call(op, function(err, entities) {\n      if (err) {\n        return callback(err);\n      }\n\n      var entityObjects = entities.map(function(entity) {\n        return type === 'node'\n          ? self._createNodeObject(entity)\n          : self._createRelationshipObject(entity);\n      });\n\n      callback(null, entityObjects);\n    });\n  },\n\n  read: function(type, indexName, key, value, callback) {\n    indexModule.readAsList.call(this, type, indexName, key, value, function (err, results) {\n      if (err) return callback(err);\n\n      if (results.length === 1) {\n        callback(null, results[0]);\n      } else if (results.length === 0) {\n        callback(null, false);\n      } else {\n        callback(null, results);\n      }\n    });\n  },\n\n  getOrSaveUnique: saveUnique('get_or_create'),\n  saveUniqueOrFail: saveUnique('create_or_fail'),\n\n  remove: function(type, indexName, obj, key, value, callback) {\n    if (typeof key === 'function') {\n      callback = key, key = null, value = null;\n    } else if (typeof value === 'function') {\n      callback = value, value = null;\n    }\n    \n    if (Array.isArray(obj)) {\n      var txn = this._safeBatch();\n      var args = [indexName, key, value];\n      var rm = naan.ecurry(txn[type].legacyindex.remove, args, [0, 2, 3]);\n      async.map(obj, rm, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    var id = this._getId(obj);\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    indexName = encodeURIComponent(indexName);\n    var endpoint = util.format('index/%s/%s', type, indexName);\n  \n    if (key) endpoint += '/' + encodeURIComponent(key);\n    if (value) endpoint += '/' + encodeURIComponent(value)\n\n    endpoint += '/' + id;\n\n    var op = this.operation(endpoint, 'DELETE');\n    this.call(op, function(err) {\n      callback(err);\n    });\n  },\n\n  delete: function(type, indexName, callback) {\n    if (Array.isArray(indexName)) {\n      var txn = this._safeBatch();\n      async.map(indexName, txn[type].legacyindex.delete, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    indexName = encodeURIComponent(indexName);\n    var endpoint = util.format('index/%s/%s', type, indexName);\n    var op = this.operation(endpoint, 'DELETE');\n    this.call(op, function(err) {\n      callback(err);\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/lib/node.js":"var async = require('async');\nvar naan = require('naan');\nvar _ = require('underscore');\nvar util = require('util');\n\nvar node = module.exports = {\n  /**\n   * Save or update an object. If a new object is passed, the callback will\n   * return a copy of that object with the <options.id> key set to the id of the\n   * created object.\n   */\n  save: function(obj, key, val, callback) {\n    if (typeof key == 'function') {\n      callback = key;\n      key = val = undefined;\n    } else if (typeof val == 'function') {\n      callback = val;\n      val = undefined;\n    }\n\n    var label = undefined;\n    if (key != undefined && val == undefined) label = key;\n\n    if (label) {\n      if (this.isBatch) {\n        return callback(new Error(\"node.save with labels is not compatible with \"\n                + \"batch mode. Use db.save & db.label instead.\"));\n      }\n      var txn = this._safeBatch();\n      var node = txn.save(obj);\n      if (obj[this.options.id] != null) node = txn.read(obj);\n      txn.label(node, label);\n      return this._safeBatchCommit(txn, function(err, result) {\n        if (err) callback(err);\n        else callback(null, result[node]);\n      });\n    } \n\n    if (Array.isArray(obj)) {\n      var txn = this._safeBatch();\n      var args = [key, val];\n      async.map(obj, naan.ecurry(txn.save, args, [1, 2]), callback);\n      return this._safeBatchCommit(txn);\n    }\n    \n    var id = this._getId(obj, !key);\n    \n    if (!this._isValidId(id)) {\n      if (typeof obj !== 'object') {\n        return callback(new Error(\"No data to save\"));\n      }\n\n      this.node._create(obj, callback);\n    } else {\n      if (val) this.node._updateProp(obj, key, val, callback);\n      else this.node._update(obj, callback);\n    }\n  },\n\n  /**\n   * Create a new object. Maps to /node.\n   */\n  _create: function(obj, callback) {\n    var op = this.operation('node', obj);\n    this.call(op, function(err, body, location) {\n      if (err) {\n        return callback(err);\n      }\n\n      var result = _.clone(obj);\n      result[this.options.id] = this._extractId(location);\n\n      callback(null, result);\n    });\n  },\n\n  /**\n   * Save the properties of an object. Maps to PUT /node/{id}/properties.\n   */\n  _update: function(obj, callback) {\n    var id = this._getId(obj, true);\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var untouchedObj = _.clone(obj);\n    if (untouchedObj[this.options.id] != null) {\n      delete untouchedObj[this.options.id];\n    }\n\n    var endpoint = util.format('%s/properties', this._nodeRoot(id));\n    var op = this.operation(endpoint, 'PUT', untouchedObj);\n    this.call(op, function(err, body, response) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, obj);\n      }\n    });\n  },\n\n  _updateProp: function(obj, key, val, callback) {\n    var id = this._getId(obj);\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var endpoint = util.format('%s/properties/%s', this._nodeRoot(id), key);\n    var op = this.operation(endpoint, 'PUT', val);\n    this.call(op, function(err, body) {\n      if (err) return callback(err);\n      else {\n        obj = _.clone(obj);\n        obj[key] = val;\n        callback(null, obj);\n      }\n    });\n  },\n\n  /**\n   * Read an object's properties. Maps to GET node/{id}/properties.\n   */\n  read: function(id, property, callback) {\n    if (typeof property == 'function') {\n      callback = property;\n      property = null;\n    }\n\n    if (Array.isArray(id)) {\n      var txn = this._safeBatch();\n      async.map(id, naan.ncurry(txn.read, property, 1), callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    id = this._getId(id);\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var endpoint;\n    if (!property) \n      endpoint = util.format('%s/properties', this._nodeRoot(id));\n    else\n      endpoint = util.format('%s/properties/%s', this._nodeRoot(id), property);\n    var op = this.operation(endpoint);\n    this.call(op, function(err, body) {\n      if (err) {\n        return callback(err);\n      } else {\n        if (!property) body[this.options.id] = id;\n        return callback(null, body);\n      }\n    });\n  },\n\n  /**\n   * Delete an object. Maps to DELETE node/{id}\n   * If force is truthy, delete node and all its relations.\n   */\n  delete: function(id, force, callback) {\n    var property = null;\n    if (typeof force == 'function') {\n      callback = force;\n      force = false;\n    } else if (typeof force == 'string') {\n      property = force;\n      force = false;\n    }\n\n    if (Array.isArray(id)) {\n      var txn = this._safeBatch();\n      async.map(id, naan.ncurry(txn.node.delete, force || property, 1), callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    var object = id;\n    id = this._getId(id);\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    if (!force) {\n      var endpoint;\n      if (!property) endpoint = this._nodeRoot(id);\n      else\n        endpoint = util.format('%s/properties/%s', this._nodeRoot(id), property);\n      var op = this.operation(endpoint, 'DELETE');\n      this.call(op, function(err) { \n        if (!property || err || typeof object != 'object') callback(err);\n        else {\n          delete object[property];\n          callback(null, object);\n        }\n      });\n    } else {\n      this.query([\n        'START node=node({root})',\n        'OPTIONAL MATCH (node)-[rel]-()',\n        'DELETE node, rel'\n      ].join(' '), {root: id}, function(err) { callback(err) });\n    }\n  },\n\n  /**\n   * Relate objects together. maps to POST node/{first}/relationships\n   */\n  relate: function(startNode, type, endNode, properties, callback) {\n    this.rel.create(startNode, type, endNode, properties, callback);\n  },\n\n  /**\n   * Retrieve a set of relationships for the given node. Optionally specify the\n   * direction and relationship name.\n   *\n   * `direction` must be one of \"all\", \"in\" or \"out\".\n   *\n   * db.relationships(obj|id, [direction, [relationshipName]], callback)\n   */\n  relationships: function(obj, direction, relName, callback) {\n    if (typeof direction === 'function') {\n      callback = direction;\n      direction = 'all';\n      relName = '';\n    } else {\n      if (typeof relName === 'function') {\n        callback = relName;\n        relName = '';\n      }\n\n      if (typeof direction !== 'string') {\n        return callback(new Error('Invalid direction - ' + direction));\n      } else if (typeof relName !== 'string') {\n        return callback(new Error('Invalid relationship name - ' + relName));\n      }\n\n      direction = direction.toLowerCase();\n      if (['in', 'all', 'out'].indexOf(direction) === -1) {\n        return callback(new Error('Invalid direction - ' + direction));\n      }\n    }\n\n    if (Array.isArray(obj)) {\n      var txn = this._safeBatch();\n      var args = [ direction, relName ];\n      var rels = naan.ecurry(txn.node.relationships, args, [1, 2]);\n      async.map(obj, rels, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    var objId = this._getId(obj);\n\n    if (!this._isValidId(objId)) {\n      callback(new Error(\"Invalid ID\"));\n    }\n\n    var nodeRoot = this._nodeRoot(objId);\n    var endpoint = util.format('%s/relationships/%s', nodeRoot, direction);\n    if (relName) {\n      endpoint += \"/\" + relName;\n    }\n    var op = this.operation(endpoint);\n    var self = this;\n    this.call(op, function(err, rels) {\n      if (err) {\n        callback(err);\n      } else {\n        rels = rels.map(function(rel) {\n          return self._createRelationshipObject(rel);\n        });\n        callback(null, rels);\n      }\n    });\n  },\n\n  /**\n   * Perform a query based on a predicate. The predicate is translated to a\n   * cypher query.\n   */\n  find: function(predicate, any, label, callback) {\n    if (typeof any == 'function') {\n      callback = any;\n      any = false;\n      label = null;\n    } else if (typeof label == 'function') {\n      callback = label;\n      if (typeof any == 'string') {\n        label = any;\n        any = false;\n      } else {\n        label = null;\n      }\n    } \n    \n    if (Array.isArray(predicate)) {\n      var txn = this._safeBatch();\n      var finder = naan.ecurry(txn.node.find, [any, label], [1, 2]);\n      async.map(predicate, finder, callback);\n      return this._safeBatchCommit(txn);\n    } \n\n    if (typeof predicate !== 'object') callback(new Error('Invalid Predicate'));\n\n    var matchers = Object.keys(predicate).reduce(function(matchers, key) {\n      return matchers.push(util.format(\"n.%s = {%s}\", key, key)), matchers;\n    }, []);\n\n    var cypher = [ \n      label == null ? \"MATCH (n)\" : util.format(\"MATCH (n:`%s`)\", label),\n      matchers.length > 0 ? \"WHERE\" : \"\",\n      matchers.join(any ? \" or \" : \" and \"), \n      \"RETURN n\"\n    ].join(\" \");\n\n    this.query(cypher, predicate, callback);\n  },\n\n  label: function(node, label, replace, callback) {\n    if (typeof replace == 'function') {\n      callback = replace;\n      replace = false;\n    }\n\n    if (Array.isArray(node)) {\n      var txn = this._safeBatch();\n      async.map(node, naan.ecurry(txn.label, [label, replace], [1,2]), callback);\n      return this._safeBatchCommit(txn);\n    }\n    \n    var id = this._getId(node);\n    if (!this._isValidId(id)) return callback(new Error(\"Invalid ID\"));\n\n    var endpoint = util.format('%s/labels', this._nodeRoot(id));\n    var op = this.operation(endpoint, replace ? 'PUT' : 'POST', label);\n    this.call(op, function(err) {\n      if (err) callback(err);\n      else callback();\n    });\n  },\n\n  removeLabel: function(node, label, callback) {\n    if (Array.isArray(node)) {\n      var txn = this._safeBatch();\n      async.map(node, naan.ncurry(txn.removeLabel, label, 1), callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    var id = this._getId(node);\n    if (!this._isValidId(id)) return callback(new Error(\"Invalid ID\"));\n\n    var endpoint = util.format('%s/labels/%s', this._nodeRoot(id), label);\n    var op = this.operation(endpoint, 'DELETE');\n    this.call(op, function(err) {\n      if (err) callback(err);\n      else callback();\n    });\n  },\n\n  nodesWithLabel: function(label, callback) {\n    var endpoint = util.format('label/%s/nodes', label);\n    var op = this.operation(endpoint, 'GET');\n    this.call(op, function(err, nodes) {\n      if (err || !nodes) return callback(err, nodes);\n      nodes = nodes.map(this._createNodeObject);\n      callback(null, nodes);\n    });\n  },\n\n  readLabels: function(node, callback) {\n    if (typeof node == 'function') {\n      callback = node;\n      node = undefined;\n    }\n\n    if (Array.isArray(node)) {\n      var txn = this._safeBatch();\n      async.map(node, txn.readLabels, function(err, allLabels) {\n        if (err) return callback(err);\n        callback(null, _.uniq(_.flatten(allLabels)));\n      });\n      return this._safeBatchCommit(txn);\n    }\n\n    var endpoint;\n    if (node) {\n      var id = this._getId(node);\n      if (!this._isValidId(id)) return callback(new Error(\"Invalid ID\"));\n      endpoint = util.format('%s/labels', this._nodeRoot(id));\n    } else {\n      endpoint = 'labels';\n    }\n    var op = this.operation(endpoint, 'GET');\n    this.call(op, function(err, labels) {\n      if (err) callback(err);\n      else callback(null, labels);\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/lib/relationship.js":"var async = require('async');\nvar naan = require('naan');\nvar _ = require('underscore');\nvar util = require('util');\n\nmodule.exports = {\n  /**\n   * Create a new relationship between two nodes. Maps to \n   * POST node/<startNodeId>/relationship\n   */\n  create: function(startNode, type, endNode, properties, callback) {\n    if (typeof properties === 'function') {\n      callback = properties;\n      properties = null;\n    }\n\n    if (Array.isArray(startNode)) {\n      var txn = this._safeBatch();\n      var args = [ type, endNode, properties ];\n      async.map(startNode, naan.ecurry(txn.rel.create, args, [1,2,3]), \n          function(err, rels) {\n            if (!err && Array.isArray(endNode))\n              return callback(err, _.flatten(rels));\n            callback(err, rels);\n          });\n      return this._safeBatchCommit(txn);\n    } else if (Array.isArray(endNode)) {\n      var txn = this._safeBatch();\n      var args = [ startNode, type, properties ];\n      async.map(endNode, naan.ecurry(txn.rel.create, args, [0,1,3]), callback);\n      return this._safeBatchCommit(txn);\n    }\n    \n    var startNodeId = this._getId(startNode),\n        endNodeId = this._getId(endNode);\n\n    if (!this._isValidId(startNodeId) ||\n        !this._isValidId(endNodeId)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var request = {\n      to: this._location('node', endNodeId),\n      type: type,\n    };\n\n    if (properties) {\n      request['data'] = properties;\n    }\n\n    var endpoint = util.format('%s/relationships', this._nodeRoot(startNodeId));\n    var op = this.operation(endpoint, 'POST', request);\n    this.call(op, function(err, rel) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, this._createRelationshipObject(rel));\n      }\n    });\n  },\n\n  /**\n   * Update the properties of a given relationship. Maps to\n   * PUT relationship/<id>/properties\n   */\n  update: function(rel, key, val, callback) {\n    if (typeof key == 'function') {\n      callback = key;\n      key = val = undefined;\n    }\n\n    if (Array.isArray(rel)) {\n      var txn = this._safeBatch();\n      var args = [key, val];\n      async.map(rel, naan.ecurry(txn.rel.update, args, [1, 2]), callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    var id = this._getId(rel);\n\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var endpoint = util.format('%s/properties', this._relRoot(id));\n    if (key) endpoint += '/' + key;\n\n    var op = this.operation(endpoint, 'PUT', key ? val : rel.properties);\n    this.call(op, function(err) {\n      callback(err);\n    });\n  }, \n\n  read: function(id, callback) {\n    if (Array.isArray(id)) {\n      var txn = this._safeBatch();\n      async.map(id, txn.rel.read, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    id = this._getId(id);\n\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var endpoint = this._relRoot(id);\n    var op = this.operation(endpoint);\n    this.call(op, function(err, rel) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, this._createRelationshipObject(rel));\n      }\n    });\n  },\n\n  delete: function(id, callback) {\n    if (Array.isArray(id)) {\n      var txn = this._safeBatch();\n      async.map(id, txn.rel.delete, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    id = this._getId(id);\n\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var endpoint = this._relRoot(id);\n    var op = this.operation(endpoint, 'DELETE');\n    this.call(op, function(err, rel) {\n      callback(err);\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/lib/bolt/seraph.js":"'use strict';\nconst url = require('url');\nconst neo4j = require('neo4j-driver').v1;\nconst _ = require('underscore');\nconst asCallback = require('ascallback');\n\nconst proxyFilter = function(db) {\n  if (db.options.nodeify) {\n    db = new Proxy(db, {\n      get: function(target, name) {\n        if (name in target && typeof target[name] == 'function') {\n          return function() {\n            if (typeof arguments[arguments.length - 1] != 'function') {\n              return target[name].apply(target, arguments);\n            }\n            const args = [].slice.call(arguments, 0, arguments.length - 1);\n            const cb = arguments[arguments.length - 1];\n            \n            return asCallback(target[name].apply(target, args), cb);\n          }\n        } else {\n          return target[name]\n        }\n      }\n    });\n  }\n\n  var recursiveProxy = (obj) => {\n    return new Proxy(obj, {\n      get: (_, k) => {\n        if (!obj[k]) return undefined;\n        if (typeof obj[k] == 'object') return recursiveProxy(obj[k]);\n        return db[obj[k]].bind(db);\n      }\n    });\n  }\n\n  return new Proxy(db, {\n    get: (target, key) => {\n      if (target[key]) return target[key];\n      var proxy = proxyMap[key];\n      if (!proxy) return undefined;\n      if (typeof proxy == 'object') return recursiveProxy(proxy);\n      else return db[proxy].bind(db);\n    }\n  })\n}\n\nvar seraph = module.exports = (opts) => proxyFilter(new Seraph(opts))\n\nvar proxyMap = {\n  node: {\n    save: 'save',\n    find: 'find',\n    delete: 'delete',\n    read: 'read',\n    relate: 'relate',\n    relationships: 'relationships',\n    label: 'label',\n    removeLabel: 'removeLabel',\n    nodesWithLabel: 'nodesWithLabel',\n    readLabels: 'readLabels'\n  },\n  constraints: {\n    uniqueness: {\n      create: 'createUniquenessConstraint',\n      createIfNone: 'createUniquenessConstraint',\n      drop: 'dropUniquenessConstraint'\n    }\n  },\n  index: {\n    create: 'createIndex',\n    drop: 'dropIndex'\n  },\n  rel: {\n    read: 'readRel',\n    create: 'createRel',\n    update: 'updateRel',\n    delete: 'deleteRel'\n  }\n}\n\nclass Seraph {\n  constructor(options) {\n    if (!options) options = 'bolt://neo4j:neo4j@localhost';\n    if (typeof options != 'object') {\n      var server = url.parse(options);\n      options = {\n        user: server.auth ? server.auth.split(':')[0] : 'neo4j',\n        pass: server.auth ? server.auth.split(':')[1] : 'neo4j'\n      };\n      delete server.auth;\n      options.server = url.format(server);\n    }\n\n    options.user = options.user || 'neo4j';\n    options.pass = options.pass || 'neo4j';   \n    options.server = options.server || 'bolt://localhost';\n    options.id = options.id || 'id';\n\n    this.options = options;\n    this.driver = options.driver ||  neo4j.driver(options.server, neo4j.auth.basic(options.user, options.pass));\n    this.options.unboxInts = options.unboxInts === false ? false : true;\n  }\n\n  _unboxInt(i) {\n    return this.options.unboxInts ? i.toNumber() : i;\n  }\n\n  _unboxAll(obj) {\n    Object.keys(obj).forEach((key) => {\n      if (neo4j.isInt(obj[key])) obj[key] = this._unboxInt(obj[key]);\n    });\n    return obj;\n  }\n\n  _getId(obj, requireData) {\n    return new Promise((resolve, reject) => {\n      if (neo4j.isInt(obj)) return resolve(obj);\n      var id;\n      if (requireData) {\n        id = typeof obj == 'object' ? obj[this.options.id] : undefined;\n      } else {\n        id = typeof obj == 'object' ? obj[this.options.id] : obj;\n      }\n\n      if (id != null) id = parseInt(id, 10);\n      if (isNaN(id) || id == null) return reject(new Error(\"Invalid ID\"));\n      resolve(neo4j.int(id));\n    });\n  }\n\n  _processResult(result, singleOrNull) {\n    var records = result.records;\n    var assemble = (field) => {\n      if (Array.isArray(field)) return field.map(assemble);\n      else if (typeof field != 'object' || !field) return field;\n      else if (neo4j.isInt(field)) return this._unboxInt(field);\n      else if (field instanceof neo4j.types.Node) {\n        var obj = field.properties;\n        if (this.options.label) obj.labels = field.labels;\n        obj[this.options.id] = this._unboxInt(field.identity);\n        return this._unboxAll(obj);\n      }\n      else if (field instanceof neo4j.types.Relationship) {\n        field.start = this._unboxInt(field.start);\n        field.end = this._unboxInt(field.end);\n        field[this.options.id] = this._unboxInt(field.identity);\n        if (this.options.id != 'identity') delete field.identity;\n        field.properties = this._unboxAll(field.properties);\n        return field;\n      }\n      else if (field instanceof neo4j.types.UnboundRelationship ||\n               field instanceof neo4j.types.PathSegment ||\n               field instanceof neo4j.types.Path) {\n        // no processing for these types yet.\n        return field;\n      }\n      else {\n        return _.reduce(field, (obj, val, key) => {\n          obj[key] = assemble(val);\n          return obj;\n        }, {});\n      }\n    }\n    var processed = records.map((record) => {\n      var row = {};\n      record.keys.forEach((key) => {\n        row[key] = assemble(record._fields[record._fieldLookup[key]])\n      });\n      if (record.keys.length == 1 && typeof row[record.keys[0]] == 'object') {\n        return row[record.keys[0]];\n      } else {\n        return row;\n      }\n    });\n    if (singleOrNull) processed = this._selectSingleOrNull(processed);\n    return processed;\n  }\n\n  _selectSingleOrNull(results) {\n    return results.length > 0 ? results[0] : null;\n  }\n\n  _session() {\n    return this.options.session || this.driver.session();\n  }\n\n  _endSession(sess) {\n    return (passthrough) => {\n      if (this.options.session != sess) sess.close();\n      return passthrough;\n    }\n  }\n\n  _aggregates(key) {\n    return Array.isArray(key) || key instanceof Promise;\n  }\n\n  _aggregate(fn, arr, argnum, allargs) {\n    if (arr instanceof Promise) {\n      return arr.then((result) => {\n        if (this._aggregates(result)) return this._aggregate(fn, result, argnum, allargs);\n        allargs[argnum] = result;\n        return fn.apply(this, allargs);\n      });\n    }\n\n    var sess = this.options.session ? this : this.session();\n\n    var flatten = false;\n    sess = new Proxy(sess, { get: (target, key) => {\n      if (key == '_aggregate') flatten = true;\n      return target[key];\n    } });\n\n    \n    var promises = arr.map(arg => {\n        allargs[argnum] = arg;\n        return fn.apply(sess, allargs);\n      });\n    var aggregated = Promise.all(promises)\n      .then(result => {\n        return flatten ? _.flatten(result, true) : result;\n      });\n\n    if (!this.options.session) {\n      aggregated = aggregated\n        .then((r) => { return sess.close(), r })\n        .catch((e) => {\n          sess.close();\n          return new Promise((_, r) => r(e))\n        });\n    }\n\n    return _.extend(aggregated, _.object(_.range(arr.length), promises));\n  }\n\n  _treatParams(params) {\n    var pr = (v) => { return new Promise(r => r(v)) };\n    var treatObj = obj => {\n      if (typeof obj == 'number') return pr(obj % 1 === 0 ? neo4j.int(obj) : obj);\n      else if (obj instanceof Promise) return obj.then(val => treatObj(val));\n      else if (neo4j.isInt(obj)) return pr(obj);\n      else if (Array.isArray(obj)) return Promise.all(obj.map(treatObj));\n      else if (typeof obj == 'object') \n        return Promise.all(_.map(obj, (v,k) => { return treatObj(v).then(v => [k,v]) }))\n          .then(tuples => _.object(tuples))\n      else return pr(obj);\n    }\n    return params ? treatObj(params) : pr(params);\n  }\n\n  _run(query, params) {\n    var sess = this._session();\n    return this._treatParams(params)\n      .then(params => sess.run(query, params))\n      .then(this._endSession(sess))\n      .catch((e) => {\n        this._endSession(sess)();\n        return new Promise((_, r) => r(e));\n      });\n  }\n\n  session() { \n    var sess = this.driver.session();\n    var sessSeraph = seraph(_.clone(this.options));\n    sessSeraph.options.session = sess;\n    return sessSeraph;\n  }\n\n  close() {\n    this.options.session && this.options.session.close();\n  }\n\n  transaction(aggregateResults) {\n    var sess = this._session();\n    var txn = sess.beginTransaction();\n    \n    var txnSeraph = new Seraph(_.clone(this.options));\n    if (aggregateResults) {\n      var ops = [];\n      txnSeraph.commit = () => {\n        return Promise.all(ops).then(result => {\n          return txn.commit().then(() => result)\n        })\n      }\n      txnSeraph = new Proxy(txnSeraph, { get: (target, key) => {\n        if (typeof target[key] != 'function') return target[key];\n        return function() {\n          var result = target[key].apply(target, arguments);\n          if (result instanceof Promise) {\n            var idx = ops.push(result) - 1;\n            Object.defineProperty(result, 'toString', {\n              enumerable: false, configurable: false, writable: false,\n              value: () => idx });\n            Object.defineProperty(result, 'valueOf', {\n              enumerable: false, configurable: false, writable: false,\n              value: () => idx });\n          }\n          return result;\n        }\n      }});\n    } else {\n      txnSeraph.commit = () => txn.commit()\n    }\n\n    txnSeraph.rollback = () => txn.rollback()\n    txnSeraph.options.session = txn;\n    txnSeraph.isTransaction = txnSeraph.isBatch = true;\n    \n    return proxyFilter(txnSeraph);\n  }\n  \n  batch() {\n    return this.transaction(true);\n  }\n\n  query(cypher, params) {\n    return this._run(cypher, params)\n      .then((result) => this._processResult(result));\n  }\n\n  find(predicate, any, label) {\n    if (this._aggregates(predicate)) return this._aggregate(this.find, predicate, 0, arguments);\n\n    if (typeof any != 'boolean') {\n      label = any;\n      any = false;\n    }\n\n    var matchers = _.map(predicate, (_, key) => `node.${key} = {${key}}`);\n    var label = label ? `:\\`${label}\\`` : '';\n\n    return this.query(`\n      MATCH (node${label})\n      ${ matchers.length ? 'WHERE' : '' } \n      ${ matchers.join(any ? ' OR ' : ' AND ') }\n      RETURN node\n    `, predicate);\n  }\n\n  read(node, prop) {\n    if (this._aggregates(node)) return this._aggregate(this.read, node, 0, arguments);\n    return this._getId(node)\n      .then((id) => {\n        return this._run(`\n          MATCH (node) WHERE id(node) = {id}\n          RETURN ${prop ? \"node.\" + prop : \"node\"}\n        `, {id});\n      })\n      .then((result) => {\n        result = this._processResult(result, true)\n        if (prop && result != null) result = result[\"node.\" + prop];\n        return result;\n      })\n  }\n\n  save(node, label) {\n    if (this._aggregates(node)) return this._aggregate(this.save, node, 0, arguments);\n    if (arguments[2] != null) return this._saveProperty(node, arguments[1], arguments[2]);\n\n    if (label) {\n      if (!Array.isArray(label)) label = [label];\n      label = label.map(l => `SET node:${l}`).join(' ');\n    } else {\n      label = '';\n    }\n\n    return this._getId(node)\n      .then(id => {\n        var props = _.omit(node, this.options.id);\n        return this._run(`\n          MATCH (node) WHERE id(node) = {id}\n          SET node = {props} ${label}\n          RETURN node\n        `, { id, props });\n      })\n      .catch(() => {\n        return this._run(`\n          CREATE (node) \n          SET node = {node} ${label}\n          RETURN node\n        `, {node})\n      })\n      .then((result) => this._processResult(result, true))\n  }\n\n  _saveProperty(node, key, value) {\n    return this._getId(node)\n      .then(id => {\n        return this._run(`\n          MATCH (node) WHERE id(node) = {id}\n          SET node.${key} = {value}\n          RETURN node\n        `, { id, value });\n      })\n      .then((result) => this._processResult(result, true))\n  }\n\n  delete(node, detach) {\n    if (this._aggregates(node)) return this._aggregate(this.delete, node, 0, arguments);\n    if (detach != null && typeof detach != 'boolean') return this.remove(node, detach);\n\n    return this._getId(node)\n      .then(id => {\n        return this._run(`\n          MATCH (node) WHERE id(node) = {id}\n          ${detach ? 'detach' : ''} DELETE node\n        `, { id })\n      })\n      .then(() => true);\n  }\n\n  remove(node, prop) {\n    if (this._aggregates(node)) return this._aggregate(this.remove, node, 0, arguments);\n    return this._getId(node)\n      .then(id => {\n        return this._run(`\n          MATCH (node) WHERE id(node) = {id}\n          REMOVE node.${prop}\n          RETURN node\n        `, { id })\n      })\n      .then((result) => this._processResult(result, true))\n  }\n\n  label(node, labels, replace) {\n    if (this._aggregates(node)) return this._aggregate(this.label, node, 0, arguments);\n    if (!Array.isArray(labels)) labels = [labels];\n    \n    var sets = labels.map(l => `SET node:\\`${l}\\``)\n    \n    var id = this._getId(node)\n    \n    if (replace) {\n      id = id.then(id => {\n        return this.readLabels(id).then(labels => { return {labels, id} })\n      })\n    } else id = id.then(id => { return { id } })\n\n    return id.then(args => {\n        var query = `MATCH (node) WHERE id(node) = {id} `;\n        query += `SET node${labels.map(l => `:\\`${l}\\``).join('')}`;\n        if (replace && args.labels.length > 0) \n          query += `REMOVE node${args.labels.map(l => `:\\`${l}\\``).join('')}`;\n        return this._run(query, {id:args.id});\n      })\n      .then(() => true);\n  }\n\n  nodesWithLabel(label) {\n    return this.query(`MATCH (n:${label}) RETURN n`)\n  }\n\n  readLabels(node) {\n    if (this._aggregates(node)) {\n      return this._aggregate(this.readLabels, node, 0, arguments).then(l => _.uniq(_.flatten(l)));\n    }\n\n    return this._getId(node)\n      .then(id => this._run(`MATCH (node) WHERE id(node) = {id} RETURN labels(node)`, { id }))\n      .catch(() => this._run(`MATCH (node) WITH labels(node) as n UNWIND n as l RETURN collect(DISTINCT l)`))\n      .then((result) => {\n        var rows = this._processResult(result)\n        return rows[0] || [];\n      })\n  }\n\n  removeLabel(node, labels) {\n    if (this._aggregates(node)) return this._aggregate(this.removeLabel, node, 0, arguments);\n    if (!Array.isArray(labels)) labels = [labels];\n    labels = labels.map(l => `:\\`${l}\\``);\n    return this._getId(node)\n      .then(id => {\n        return this._run(`\n          MATCH (node) WHERE id(node) = {id}\n          REMOVE node${labels}\n        `, { id });\n      })\n      .then(() => true);\n  }\n\n  relationships(node, direction, type) {\n    if (this._aggregates(node)) return this._aggregate(this.relationships, node, 0, arguments);\n    if (direction == null) direction = 'all';\n    \n    type = type == null ? '' : `:\\`${type}\\``;\n    var query = `${direction == 'in' ? '<' : ''}-[rel${type}]-${direction == 'out' ? '>' : ''}`;\n\n    return this._getId(node)\n      .then(id => {\n        return this.query(`\n          MATCH (node)${query}(to)\n          WHERE id(node) = {id}\n          RETURN rel\n        `, { id });\n      })\n  }\n\n  readRel(rel) {\n    if (this._aggregates(rel)) return this._aggregate(this.readRel, rel, 0, arguments);\n    return this._getId(rel)\n      .then(id => {\n        return this._run(`\n          MATCH (a)-[rel]-(b)\n          WHERE id(rel) = {id}\n          RETURN rel\n        `, { id })\n      })\n      .then((result) => this._processResult(result, true))\n  }\n\n  relate() { return this.createRel.apply(this, arguments) }\n  createRel(startNode, type, endNode, properties) {\n    if (this._aggregates(startNode)) return this._aggregate(this.createRel, startNode, 0, arguments);\n    if (this._aggregates(endNode)) return this._aggregate(this.createRel, endNode, 2, arguments);\n    properties = properties || {};\n\n    return Promise.all([ this._getId(startNode), this._getId(endNode) ])\n      .then(ids => {\n        return this._run(`\n          MATCH (start), (end)\n          WHERE id(start) = {startId} AND id(end) = {endId}\n          CREATE (start)-[rel:\\`${type}\\`]->(end)\n          SET rel = {properties}\n          RETURN rel\n        `, { startId: ids[0], endId: ids[1], properties });\n      })\n      .then((result) => this._processResult(result, true))\n  }\n\n  updateRel(rel) {\n    if (this._aggregates(rel)) return this._aggregate(this.updateRel, rel, 0, arguments);\n    if (arguments[2] != null) return this._updateRelProperty.apply(this, arguments);\n    return this._getId(rel)\n      .then(id => {\n        return this._run(`\n          MATCH (a)-[rel]-(b)\n          WHERE id(rel) = {id}\n          SET rel = {props}\n          RETURN rel\n        `, { id, props: rel.properties });\n      })\n      .then((result) => this._processResult(result, true))\n  }\n\n  _updateRelProperty(rel, key, value) {\n    return this._getId(rel)\n      .then(id => {\n        return this._run(`\n          MATCH (a)-[rel]-(b)\n          WHERE id(rel) = {id}\n          SET rel.\\`${key}\\` = {value}\n          RETURN rel\n        `, { id, value });\n      })\n      .then((result) => this._processResult(result, true))\n  }\n\n  deleteRel(rel) {\n    if (this._aggregates(rel)) return this._aggregate(this.deleteRel, rel, 0, arguments);\n    return this._getId(rel)\n      .then(id => {\n        return this._run(`\n          MATCH (a)-[rel]-(b)\n          WHERE id(rel) = {id}\n          DELETE rel\n        `, { id });\n      })\n      .then(() => true)\n  }\n\n  createUniquenessConstraint(label, key) {\n    return this._run(`CREATE CONSTRAINT ON (n:\\`${label}\\`) ASSERT n.\\`${key}\\` IS UNIQUE`)\n      //compat. query returns nothing anyway\n      .then(() => { return { type: 'UNIQUENESS', label: label, property_keys: [key] } });\n  }\n\n  dropUniquenessConstraint(label, key) {\n    return this._run(`DROP CONSTRAINT ON (n:\\`${label}\\`) ASSERT n.\\`${key}\\` IS UNIQUE`)\n      //compat. query returns nothing anyway\n      .then(() => { return { type: 'UNIQUENESS', label: label, property_keys: [key] } });\n  }\n\n  createIndex(label, key) {\n    return this._run(`CREATE INDEX ON :\\`${label}\\`(\\`${key}\\`)`)\n      .then(() => true);\n  }\n  \n  dropIndex(label, key) {\n    return this._run(`DROP INDEX ON :\\`${label}\\`(\\`${key}\\`)`)\n      .then(() => true);\n  }\n}\n"}