{"/home/travis/build/npmtest/node-npmtest-seraph/test.js":"/* istanbul instrument in package npmtest_seraph */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-seraph/lib.npmtest_seraph.js":"/* istanbul instrument in package npmtest_seraph */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_seraph = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_seraph = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-seraph/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-seraph && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_seraph */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_seraph\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_seraph.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_seraph.rollup.js'] =\n            local.assetsDict['/assets.npmtest_seraph.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_seraph.__dirname + '/lib.npmtest_seraph.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/lib/seraph.js":"var naan = require('naan');\nvar async = require('async');\nvar request = require('request');\nvar _ = require('underscore');\nvar assert = require('assert');\nvar util = require('util');\nvar Core = require('seraph-core');\n\n// Bind all functions of an object to a context (recursively)\nvar bindAllTo = function(context, all) {\n  return Object.keys(all).reduce(function(bound, key) {\n    if (typeof all[key] == 'object') bound[key] = bindAllTo(context, all[key]);\n    else if (typeof all[key] == 'function') bound[key] = all[key].bind(context);\n    else bound[key] = all[key];\n    return bound;\n  }, {});\n}\n\n// Polyfill Object.setPrototypeOf for older node versions.\nvar setPrototypeOf = Object.setPrototypeOf || function setPrototypeOfPolyfill(obj, proto) { obj.__proto__ = proto; };\n\nfunction Seraph(options) {\n  if (options.bolt) return require('./bolt/seraph')(options);\n  var core = new Core(options);\n\n  setPrototypeOf(Object.getPrototypeOf(this), core);\n  this.options = core.options;\n\n  _.bindAll.apply(_, [this].concat(_.functions(this)));\n\n  this.node = bindAllTo(this, require('./node'));\n  this.relationship = this.rel = bindAllTo(this, require('./relationship'));\n  this.index = bindAllTo(this, require('./index'));\n  this.constraints = bindAllTo(this, require('./constraints'));\n  var legacyindexGeneric = bindAllTo(this, require('./legacyindex'));\n\n\n  // Alias & curry seraph.index on seraph.node & seraph.rel\n  this.node.legacyindex = naan.curry(legacyindexGeneric.add, 'node');\n  this.rel.legacyindex = naan.curry(legacyindexGeneric.add, 'relationship');\n  naan.ecrock(this.node.legacyindex, legacyindexGeneric, naan.curry, 'node');\n  naan.ecrock(this.rel.legacyindex, legacyindexGeneric, naan.curry, 'relationship');\n\n  _.extend(this, this.node);\n}\n\n\n// returns a new batch if the context was not already that of a batch - prevents\n// batch nesting which can break intra-batch referencing\nSeraph.prototype._safeBatch = function() {\n  return this.isBatch ? this : this.batch();\n};\n\n// similarly, this takes a BatchSeraph and only commits it if the calling context \n// is not that of a batch.\nSeraph.prototype._safeBatchCommit = function(txn, callback) {\n  if (this.isBatch) {\n    if (callback) this.commitCallbacks.push(callback);\n  } else {\n    txn.commit(callback);\n  }\n};\n\n/**\n * If `obj` is an object, return the value of key <options.id>. Otherwise,\n * return `obj`.\n *\n * If `requireData` is truthy, `obj` must be an object, otherwise undefined is\n * returned.\n */\nSeraph.prototype._getId = function(obj, requireData) {\n  var id;\n  if (requireData) {\n    id = typeof obj == 'object' ? obj[this.options.id] : undefined;\n  } else if (this._isBatchId(obj)) {\n    return obj;\n  } else {\n    id = typeof obj == 'object' ? obj[this.options.id] : obj;\n  }\n\n  if (id != null) id = parseInt(id, 10);\n  return id;\n};\n\nSeraph.prototype._isValidId = function(id) {\n  return !isNaN(parseInt(id, 10)) || this._isBatchId(id);\n};\n\n/**\n * Take the end off a url and parse it as an int\n */\nSeraph.prototype._extractId = function(location) {\n  var matches = location.match(/\\/(\\d+)$/);\n  if (!matches) {\n    return null;\n  }\n\n  return parseInt(matches[1], 10);\n};\n\n/**\n * Infer whether or not the given object is a node\n */\nSeraph.nodeFlags = [ \n  'outgoing_relationships',\n  'incoming_relationships',\n  'all_relationships',\n  'data',\n  'properties',\n  'self'\n];\nSeraph.prototype._isNode = function(node) {\n  if (!node || typeof node !== 'object') {\n    return false;\n  }\n\n  var inNode = node.hasOwnProperty.bind(node);\n  return Seraph.nodeFlags.every(inNode) && \n         typeof node.data === 'object';\n};\n\n/**\n * Infer whether or not the given object is a relationship\n */\nSeraph.relationshipFlags = [\n  'start',\n  'data',\n  'self',\n  'properties',\n  'end'\n];\nSeraph.prototype._isRelationship = function(rel) {\n  if (!rel || typeof rel !== 'object') {\n    return false;\n  }\n\n  var inRelationship = rel.hasOwnProperty.bind(rel);\n  return Seraph.relationshipFlags.every(inRelationship) &&\n         typeof rel.data === 'object';\n};\n\nSeraph.prototype._isBatchId = function(id) {\n  return this.isBatch && typeof id == 'string' && id.match(/^{\\d+}$/);\n};\n\nSeraph.prototype._nodeRoot = function(id) {\n  return this._isBatchId(id) ? id : 'node/' + id;\n};\n\nSeraph.prototype._relRoot = function(id) {\n  return this._isBatchId(id) ? id : 'relationship/' + id;\n};\n\n/**\n * Returns the url to an entity given an id\n */\nSeraph.prototype._location = function(type, id) {\n  if (this._isBatchId(id)) return id;\n  return util.format('%s%s/%s/%d',\n                     this.options.server, this.options.endpoint, type, id);\n};\n\n/**\n * Create a relationship object from the given relationship data returned from\n * the neo4j server\n */\nSeraph.prototype._createRelationshipObject = function(relationshipData) {\n  var relationshipObj = { \n    start: this._extractId(relationshipData.start),\n    end: this._extractId(relationshipData.end),\n    type: relationshipData.type,\n    properties: relationshipData.data\n  };\n\n  relationshipObj[this.options.id] = this._extractId(relationshipData.self);\n\n  return relationshipObj;\n};\n\n/** \n * Create a node object from the given node data return from the neo4j server\n */\nSeraph.prototype._createNodeObject = function(nodeData) {\n  var nodeObj = nodeData.data || {};\n  nodeObj[this.options.id] = this._extractId(nodeData.self);\n\n  return nodeObj;\n};\n\n  /**\n   * Perform a cypher query. Maps to POST cypher\n   */\nSeraph.prototype.queryRaw = function(query, params, callback) {\n  if (typeof query !== 'string') {\n    return callback(new Error('Invalid Query'));\n  }\n  if (typeof params !== 'object') {\n    if (typeof params === 'function') {\n      callback = params;\n    }\n    params = {};\n  }\n\n  query = { statements: [ {\n    statement: query,\n    parameters: params,\n    resultDataContents: ['REST']\n  } ] } ;\n  var op = this.operation('transaction/commit', query);\n  this.call(op, function(err, result) {\n    if (err || result.errors[0]) {\n      callback(err || result.errors[0]);\n    } else {\n      result = result.results[0];\n      result.data = result.data.map(function(row) { return row.rest });\n      callback(null, result);\n    }\n  });\n};\n\nSeraph.prototype._parseQueryResult = function(result) {\n  var self = this;\n  var namedResults = result.data.map(function(row) {\n    return result.columns.reduce(function(rowObj, columnName, columnIndex) {\n      var resultItem = row[columnIndex];\n      function extractAttributes(item) {\n        if (self._isNode(item)) {\n          return self._createNodeObject(item);\n        } else if (self._isRelationship(item)) {\n          return self._createRelationshipObject(item);\n        } else if (Array.isArray(item)) {\n          return item.map(extractAttributes);\n        } else if (item === Object(item)) {\n          return _.mapObject(item, extractAttributes);\n        } else {\n          return item;\n        }\n      }\n\n      rowObj[columnName] = extractAttributes(resultItem);\n      \n      return rowObj;\n    }, {});\n  });\n\n  if (namedResults.length > 0) {\n    var resultsAreObjects = typeof namedResults[0][result.columns[0]] == 'object';\n    if (result.columns.length === 1 && resultsAreObjects) {\n      namedResults = namedResults.map(function(namedResult) {\n        return namedResult[result.columns[0]];\n      });\n    }\n  }\n\n  return namedResults;\n}\n\n/**\n * Perform a cypher query and map the columns and results together.\n */\nSeraph.prototype.query = function(query, params, callback) {\n  if (typeof params !== 'object') {\n    if (typeof params === 'function') {\n      callback = params;\n    }\n    params = {};\n  }\n  \n  var self = this;\n  this.queryRaw(query, params, function(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    \n    callback(null, self._parseQueryResult(result));\n  });\n};\n\nvar globalCounter = 0;\nfunction wrapForBatchFormat(id) { return '{' + id + '}' };\nfunction BatchSeraphId(id, refersTo, batch) {\n  if (Array.isArray(refersTo)) {\n    refersTo = refersTo.map(wrapForBatchFormat);\n    refersTo.forEach(function(id, index) {\n      this[index] = id;\n    }.bind(this));\n  } else {\n    refersTo = wrapForBatchFormat(refersTo);\n  }\n\n  this.id = id;\n  this.refersTo = refersTo;\n  this.batch = batch;\n}\nObject.defineProperty(BatchSeraphId.prototype, 'valueOf', {\n  enumerable: false, configurable: false, writable: false,\n  value: function() { return this.id }\n});\nObject.defineProperty(BatchSeraphId.prototype, 'toString', {\n  enumerable: false, configurable: false, writable: false,\n  value: function() { return this.id } \n});\n\nfunction BatchSeraph(parentSeraph) {\n  var self = this;\n  var uniq = Date.now() + ++globalCounter;\n\n  function isBatchId(id) {\n    return id instanceof BatchSeraphId && id.batch == uniq;\n  };\n\n  function createId(id, refersTo) {\n    return new BatchSeraphId(id, refersTo, uniq);\n  };\n\n  function transformBatchArgs(args) {\n    return args.map(function(arg) {\n      if (Array.isArray(arg)) return transformBatchArgs(arg);\n      return isBatchId(arg) ? arg.refersTo : arg;\n    });\n  };\n\n  function wrapFunctions(parent, target) {\n    var derived = target || {};\n\n    // parent could be undefined or null, so skip walking such\n    parent && Object.keys(parent).forEach(function(key) {\n      if (key == 'agent') return;\n\n      var valueType = typeof parent[key];\n\n      if (valueType === 'function') {\n        derived[key] = wrapFunction(parent[key]);\n\n        if (Object.keys(parent[key]).length > 0) {\n          derived[key] = wrapFunctions(parent[key], derived[key]);\n        }\n      } else if (valueType === 'object') {\n        derived[key] = wrapFunctions(parent[key]);\n      } else {\n        derived[key] = parent[key];\n      }\n    });\n    return derived;\n  }\n\n  function wrapFunction(fn) {\n    fn = naan.rcurry(fn, function(err, result) {\n      if (err && !self.error) self.error = err;\n      self.results.push(result);\n      var cb = self.callbacks.shift();\n      if (cb) cb(err, result);\n    });\n    return function() {\n      self.operationQueueStack.unshift([]);\n\n      var args = [].slice.apply(arguments);\n\n      if (args.length > 1 && typeof args[args.length - 1] == 'function') {\n        self.callbacks.push(args.pop());\n      } else {\n        self.callbacks.push(null);\n      }\n\n      args = transformBatchArgs(args);\n\n      // Context does not matter because all functions are bound upon seraph init\n      fn.apply(undefined, args);\n\n      var operationIds = _.pluck(self.operationQueueStack[0], 'id');\n      self.operationQueueStack.shift();\n\n      var operationId = operationIds.length \n        ? operationIds[0] - self.operationOffset : undefined;\n\n      if (operationIds.length > 1) {\n        self.operationOffset += operationIds.length - 1;\n        operationId = createId(operationId, operationIds);\n      } else if (operationId != null) {\n        operationId = createId(operationId, operationIds[0]);\n      }\n\n      return operationId;\n    };\n  }\n\n  this.super = new Seraph(parentSeraph.options);\n  this.__proto__ = wrapFunctions(this.super);\n  this.isBatch = this.super.isBatch = true;\n  this.batch = undefined; // disabled nesting.\n  this.processors = [];\n  this.operations = [];\n  this.callbacks = [];\n  this.results = [];\n  this.operationOffset = 0;\n  this.operationQueueStack = [];\n  this.commitCallbacks = [];\n\n  this.super.call = function(operation, processor) {\n    operation.id = self.operations.length;\n    if (!operation.body) delete operation.body;\n\n    self.operations.push(operation);\n    self.processors.push(processor.bind(self.super));\n    self.operationQueueStack[0].push(operation);\n  };\n  \n  function handleSelfError(error) {\n    self.commitCallbacks.forEach(function(callback) {\n      callback(error);\n    });\n  }\n  \n  this.commit = function(callback) {\n    if (callback) self.commitCallbacks.push(callback);\n    if (self.error) return handleSelfError(self.error)\n    var op = parentSeraph.operation('batch', 'POST', self.operations);\n    parentSeraph.call(op, function(err, results) {\n      if (err) {\n        while (self.callbacks.length) {\n          var cb = self.callbacks.shift();\n          if (cb) cb(err);\n        }\n        return self.commitCallbacks.forEach(function(callback) {\n          callback(err);\n        });\n      }\n\n      results.forEach(function(result) {\n        self.processors.shift()(null, result.body || {}, result.location);\n      });\n\n      if (self.error) return handleSelfError(self.error)\n      \n      self.commitCallbacks.forEach(function(callback) {\n        callback(null, self.results);\n      });\n    });\n  };\n}\n\nSeraph.prototype.isBatch = false;\n\nSeraph.prototype.batch = function(operations, callback) {\n  if (!arguments.length) return new BatchSeraph(this);\n\n  var batchSeraph = new BatchSeraph(this);\n  operations(batchSeraph);\n  batchSeraph.commit(callback);\n};\n\nmodule.exports = function(options) {\n  if (options && options.thunkify) {\n    delete options.thunkify;\n    return require('../co')(options);\n  }\n  return new Seraph(options);\n};\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph-core/seraph-core.js":"var request = require('request');\nvar _ = require('underscore');\n\nfunction SeraphCore(options) {\n  if (typeof options === 'string') {\n    options = { server: options };\n  };\n  options = _.extend({}, defaultOptions, options);\n  options.server = options.server\n    .replace(/\\/$/, '');        // remove trailing /\n  options.endpoint = options.endpoint\n    .replace(/\\/$/, '')         // remove trailing /\n    .replace(/^([^\\/])/, '/$1'); // add leading /\n\n  this.options = options;\n  var self = this;\n\n  /**\n   * Create an operation that can later be passed to call().\n   *\n   * Path is relative to the service endpoint - `node` gets\n   * transformed to `<options.server><options.endpoint>/node`.\n   * \n   * If `method` is not supplied, it will default GET, unless `data`\n   * is supplied, in which case it will default to 'POST'.\n   *\n   * seraph#operation(opts, path, [method='get'], [data]);\n   */\n  this.operation = function(path, method, data) {\n    // Get args in the right order\n    if (typeof data === 'undefined') {\n      data = null;\n    }\n    if (typeof method === 'object') {\n      data = method;\n      method = 'POST';\n    }\n    if (typeof method === 'undefined') {\n      method = 'GET';\n    }\n\n    // Ensure we have a usable HTTP verb.\n    if (typeof method !== 'string') {\n      throw new Error('Invalid HTTP Verb - ' + method);\n    } else {\n      method = method.toUpperCase();\n    }\n\n    return {\n      'method': method,\n      'endpoint': options.endpoint,\n      'to'    : path,\n      'body'  : data\n    };\n  };\n\n  /**\n   * Function to call an HTTP request to the rest service.\n   * \n   * Requires an operation object of form:\n   *   { method: 'PUT'|'POST'|'GET'|'DELETE'\n   *   , to    : path,\n   *   , body  : object }\n   *\n   * Operation objects are easily created by seraph#operation.\n   *\n   * seraph#call(operation, callback);\n   */\n  this.call = function(operation, callback) {\n    // Ensure callback is callable. Throw instead of calling back if none.\n    if (typeof callback !== 'function') {\n      callback = function(err) {\n        if (err) throw err;\n      }\n    }\n    var authString = options.authString || (options.authString = new Buffer(options.user + ':' + options.pass).toString('base64'));\n    var endpoint = operation.endpoint || options.endpoint;\n    var requestOpts = {\n      uri: options.server + endpoint + '/' + operation.to,\n      method: operation.method,\n      headers: { \n        Accept: 'application/json',\n        Authorization: 'Basic ' + authString\n      }\n    };\n\n    if (options.xstream) requestOpts.headers['X-Stream'] = true;\n\n    if (options.agent) requestOpts.agent = options.agent;\n\n    if (options.ssl)\n    {\n      requestOpts.cert = options.ssl.cert;\n      requestOpts.key = options.ssl.key;\n      requestOpts.passphrase = options.ssl.passphrase;\n      requestOpts.ca = options.ssl.ca;\n    }\n\n    if (operation.body) requestOpts.json = operation.body;\n\n    callback = callback.bind(this);\n    \n    // allow mocking of \"request\". you can mock it by reassigning this._request to\n    // something with the same API as the \"request\" module.\n    var createRequest = this._request || request;\n\n    createRequest(requestOpts, function(err, response, body) {\n      if (err) {\n        callback(err);\n      } else if (response.statusCode < 200 || response.statusCode >= 300) {\n        if (typeof body == 'string') {\n          try {\n            body = JSON.parse(body);\n          } catch (error) {}\n        }\n        // Pass on neo4j error\n        var error;\n        if (typeof body == \"object\" && body.exception) {\n          error = new Error(body.message);\n          error.neo4jError = body;\n          error.neo4jException = body.exception;\n          error.neo4jStacktrace = body.stacktrace;\n          if (body.cause) error.neo4jCause = body.cause;\n        } else {\n          if (typeof body == 'object' && body.errors) {\n            error = new Error(body.errors[0].message);\n          } else {\n            error = new Error(body || response.statusCode);\n          }\n          error.code = response.statusCode;\n          error.response = response;\n        }\n        error.statusCode = response.statusCode;\n        callback(error);\n      } else {\n        if (operation.method === 'GET' && response.statusCode === 204) {\n          var error = new Error(\"no content\");\n          error.statusCode = response.statusCode;\n          return callback(error);\n        }\n\n        _.defer(function() {\n          if (body === '') body = null;\n          else if (typeof body === 'string') {\n            try {\n              body = JSON.parse(body);\n            } catch (e) {\n              return callback(e);\n            }\n          }\n\n          callback(null, body, response.headers.location);\n        });\n      }\n    });\n  };\n\n\n  // change password\n  this.changePassword = function(newPassword, callback) {\n    var op = {\n      method: 'POST',\n      endpoint: '/user',\n      to: options.user + '/password',\n      body: { password: newPassword }\n    };\n    self.call(op, function(err, result) {\n      if (err) return callback(err);\n      options.pass = newPassword;\n      delete options.authString;\n      callback();\n    });\n  };\n}\n\nvar defaultOptions = {\n  // Location of the server\n  server: 'http://localhost:7474',\n\n  // datbase endpoint\n  endpoint: '/db/data',\n\n  // The key to use when inserting an id into objects. \n  id: 'id',\n\n  // default username and password for authentication\n  user: 'neo4j',\n  pass: 'neo4j'\n}, optionKeys = Object.keys(defaultOptions);\n\nmodule.exports = SeraphCore;\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/bolt.js":"module.exports = require('lib/bolt/seraph');\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/co.js":"var seraph = require('./lib/seraph');\nvar thunkify = require('thunkify');\nvar excludes = [\n  'batch',\n  'operation'\n];\n\nmodule.exports = function(opts) {\n  var db = seraph(opts);\n  return function wrapObject(obj) {\n    var copy = {};\n    Object.keys(obj).forEach(function(key) {\n      if (typeof obj[key] == 'function' && excludes.indexOf(key) == -1 && key[0] != '_') {\n        copy[key] = thunkify(obj[key]);\n      } else if (typeof obj[key] == 'object') {\n        copy[key] = wrapObject(obj[key]);\n      } else {\n        copy[key] = obj[key];\n      }\n    }); \n    return copy;\n  }(db);\n};\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/lib/constraints.js":"var async = require('async');\nvar naan = require('naan');\nvar _ = require('underscore');\nvar util = require('util');\n\nexports.uniqueness = {};\n\nexports.uniqueness.create = function(label, keys, callback) {\n  if (!Array.isArray(keys)) keys = [keys];\n\n  label = encodeURIComponent(label);\n  var body = { property_keys: keys };\n\n  var endpoint = util.format('schema/constraint/%s/uniqueness', label);\n  var op = this.operation(endpoint, 'POST', body);\n  this.call(op, function(err, index) {\n    if (err) callback(err);\n    else callback(null, index);\n  });\n};\n\nexports.uniqueness.createIfNone = function(label, keys, callback) {\n  var self = this;\n  exports.uniqueness.list.call(self, label, keys, function(err, constraints) {\n    if (err) {\n      if (err.statusCode != 404) return callback(err);\n    } else if (constraints.length > 0) return callback(null, constraints[0]);\n    // Seems like sometimes if this is being called very early in neo4j's init\n    // phase, the list command doesn't return a constraint, but the following\n    // calls sends back a 409. So we check for that, and don't send that error\n    // through.\n    exports.uniqueness.create.call(self, label, keys, function(err, constraint) {\n      if (err) {\n        if (err.statusCode == 409) {\n          // in this edgecase there's no way really for us to get the constraint\n          // object, so send back without (for now). hopefully there's a better\n          // way to handle this in the future.\n          return callback();\n        } else {\n          return callback(err);\n        }\n      }\n\n      callback(null, constraint);\n    });\n  });\n};\n\nexports.uniqueness.list = function(label, key, callback) {\n  if (typeof key == 'function') {\n    callback = key;\n    key = null;\n  }\n\n  label = encodeURIComponent(label);\n  var endpoint = util.format('schema/constraint/%s/uniqueness', label);\n\n  if (key) {\n    key = encodeURIComponent(key);\n    endpoint += '/' + key;\n  }\n\n  var op = this.operation(endpoint, 'GET');\n  this.call(op, function(err, constraints) {\n    if (err) callback(err);\n    else callback(null, constraints);\n  });\n};\n\nexports.uniqueness.drop = function(label, key, callback) {\n  label = encodeURIComponent(label);\n  key = encodeURIComponent(key);\n  var endpoint = util.format('schema/constraint/%s/uniqueness/%s', label, key);\n  var op = this.operation(endpoint, 'DELETE');\n  this.call(op, function(err) {\n    if (err) callback(err);\n    else callback();\n  });\n};\n\nexports.list = function(label, callback) {\n  if (typeof label == 'function') {\n    callback = label;\n    label = null; \n  }\n\n  var endpoint = 'schema/constraint';\n\n  if (label) endpoint += '/' + encodeURIComponent(label);\n\n  var op = this.operation(endpoint, 'GET');\n  this.call(op, function(err, constraints) {\n    if (err) callback(err);\n    else callback(null, constraints);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/lib/legacyindex.js":"var async = require('async');\nvar naan = require('naan');\nvar _ = require('underscore');\nvar util = require('util');\n\nfunction isValidType(type, callback) {\n  if (type !== 'node' && type !== 'relationship') {\n    callback(new Error(\"Invalid index type (should be 'node' or \" +\n          \"'relationship'.\"));\n    return false;\n  }\n  return true;\n}\n\nfunction saveUnique(mode) {\n  return function() {\n    var args = [].slice.call(arguments);\n    var type = args.shift();\n    args.push(mode);\n    if (type == 'node') return saveUniqueNode.apply(this, args);\n    else return saveUniqueRel.apply(this, args);\n  };\n};\n\nfunction saveUniqueNode(node, index, key, value, callback, mode) {\n  var self = this;\n\n  var request = {\n    key: key,\n    value: value,\n    properties: node\n  };\n\n  var endpoint = util.format('index/node/%s?uniqueness=%s', index, mode);\n  var op = this.operation(endpoint, 'POST', request);\n  this.call(op, function(err, node) {\n    if (err) return callback(err);\n    callback(null, this._createNodeObject(node));\n  });\n};\n\nfunction saveUniqueRel(start, rel, end, props, idx, key, value, cb, mode) {\n  var self = this;\n  if (typeof props == 'string') {\n    mode = cb;\n    cb = value;\n    value = key;\n    key = idx;\n    idx = props;\n    props = undefined;\n  }\n\n  start = this._getId(start);\n  end = this._getId(end);\n\n  if (!this._isValidId(start) || !this._isValidId(end)) {\n    return callback(new Error(\"Invalid ID\"));\n  }\n\n  var request = {\n    key: key,\n    value: value,\n    start: this._location('node', start),\n    end: this._location('node', end),\n    type: rel\n  };\n\n  if (props) request.properties = props;\n\n  var endpoint = util.format('index/relationship/%s?uniqueness=%s', idx, mode);\n  var op = this.operation(endpoint, 'POST', request);\n  this.call(op, function(err, rel) {\n    if (err) return cb(err);\n    cb(null, self._createRelationshipObject(rel));\n  });\n};\n\nvar indexModule = module.exports = {\n  create: function(type, name, config, callback) {\n    if (typeof name === 'function') {\n      callback = name;\n      name = type;\n      type = 'node';\n      config = null;\n    } else if (typeof config === 'function') {\n      callback = config;\n      if (typeof name === 'object' && !Array.isArray(name)) {\n        config = name;\n        name = type;\n        type = 'node';\n      } else {\n        config = null;\n      }\n    } \n\n    if (Array.isArray(name)) {\n      var txn = this._safeBatch();\n      var indexer = naan.ncurry(txn[type].legacyindex.create, config, 1);\n      async.map(name, indexer, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    if (!isValidType(type, callback)) {\n      return;\n    }\n\n    var request = { name: name };\n    if (config != null) {\n      request.config = config;\n    }\n\n    var endpoint = util.format('index/%s', type);\n    var op = this.operation(endpoint, 'POST', request);\n    this.call(op, function(err) {\n      callback(err);\n    });\n  },\n\n  add: function(type, indexName, obj, key, value, callback) {\n    if (typeof value === 'function') {\n      callback = value;\n      value = key;\n      key = obj;\n      obj = indexName;\n      indexName = type;\n      type = 'node';\n    }\n    \n    if (Array.isArray(obj)) {\n      var txn = this._safeBatch();\n      var args = [indexName, key, value];\n      var indexer = naan.ecurry(txn[type].legacyindex.add, args, [0, 2, 3]);\n      async.map(obj, indexer, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    if (!isValidType(type, callback)) {\n      return;\n    }\n\n    var id = this._getId(obj);\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n    var location = this._location(type, id);\n\n    var request = {\n      uri: location,\n      key: key,\n      value: value\n    };\n\n    indexName = encodeURIComponent(indexName);\n\n    var endpoint = util.format('index/%s/%s', type, indexName);\n    var op = this.operation(endpoint, 'POST', request);\n    this.call(op, function(err) {\n      callback(err);\n    });\n  },\n\n  readAsList: function(type, indexName, key, value, callback) {\n    if (typeof value === 'function') {\n      callback = value;\n      value = key;\n      key = indexName;\n      indexName = type;\n      type = 'node';\n    }\n\n    if (!isValidType(type, callback)) {\n      return;\n    }\n\n    indexName = encodeURIComponent(indexName);\n    value = encodeURIComponent(value); \n    key = encodeURIComponent(key);\n\n    var ep = util.format('index/%s/%s/%s/%s', type, indexName, key, value);\n    var op = this.operation(ep, 'GET');\n    var self = this;\n    this.call(op, function(err, entities) {\n      if (err) {\n        return callback(err);\n      }\n\n      var entityObjects = entities.map(function(entity) {\n        return type === 'node'\n          ? self._createNodeObject(entity)\n          : self._createRelationshipObject(entity);\n      });\n\n      callback(null, entityObjects);\n    });\n  },\n\n  read: function(type, indexName, key, value, callback) {\n    indexModule.readAsList.call(this, type, indexName, key, value, function (err, results) {\n      if (err) return callback(err);\n\n      if (results.length === 1) {\n        callback(null, results[0]);\n      } else if (results.length === 0) {\n        callback(null, false);\n      } else {\n        callback(null, results);\n      }\n    });\n  },\n\n  getOrSaveUnique: saveUnique('get_or_create'),\n  saveUniqueOrFail: saveUnique('create_or_fail'),\n\n  remove: function(type, indexName, obj, key, value, callback) {\n    if (typeof key === 'function') {\n      callback = key, key = null, value = null;\n    } else if (typeof value === 'function') {\n      callback = value, value = null;\n    }\n    \n    if (Array.isArray(obj)) {\n      var txn = this._safeBatch();\n      var args = [indexName, key, value];\n      var rm = naan.ecurry(txn[type].legacyindex.remove, args, [0, 2, 3]);\n      async.map(obj, rm, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    var id = this._getId(obj);\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    indexName = encodeURIComponent(indexName);\n    var endpoint = util.format('index/%s/%s', type, indexName);\n  \n    if (key) endpoint += '/' + encodeURIComponent(key);\n    if (value) endpoint += '/' + encodeURIComponent(value)\n\n    endpoint += '/' + id;\n\n    var op = this.operation(endpoint, 'DELETE');\n    this.call(op, function(err) {\n      callback(err);\n    });\n  },\n\n  delete: function(type, indexName, callback) {\n    if (Array.isArray(indexName)) {\n      var txn = this._safeBatch();\n      async.map(indexName, txn[type].legacyindex.delete, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    indexName = encodeURIComponent(indexName);\n    var endpoint = util.format('index/%s/%s', type, indexName);\n    var op = this.operation(endpoint, 'DELETE');\n    this.call(op, function(err) {\n      callback(err);\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/lib/node.js":"var async = require('async');\nvar naan = require('naan');\nvar _ = require('underscore');\nvar util = require('util');\n\nvar node = module.exports = {\n  /**\n   * Save or update an object. If a new object is passed, the callback will\n   * return a copy of that object with the <options.id> key set to the id of the\n   * created object.\n   */\n  save: function(obj, key, val, callback) {\n    if (typeof key == 'function') {\n      callback = key;\n      key = val = undefined;\n    } else if (typeof val == 'function') {\n      callback = val;\n      val = undefined;\n    }\n\n    var label = undefined;\n    if (key != undefined && val == undefined) label = key;\n\n    if (label) {\n      if (this.isBatch) {\n        return callback(new Error(\"node.save with labels is not compatible with \"\n                + \"batch mode. Use db.save & db.label instead.\"));\n      }\n      var txn = this._safeBatch();\n      var node = txn.save(obj);\n      if (obj[this.options.id] != null) node = txn.read(obj);\n      txn.label(node, label);\n      return this._safeBatchCommit(txn, function(err, result) {\n        if (err) callback(err);\n        else callback(null, result[node]);\n      });\n    } \n\n    if (Array.isArray(obj)) {\n      var txn = this._safeBatch();\n      var args = [key, val];\n      async.map(obj, naan.ecurry(txn.save, args, [1, 2]), callback);\n      return this._safeBatchCommit(txn);\n    }\n    \n    var id = this._getId(obj, !key);\n    \n    if (!this._isValidId(id)) {\n      if (typeof obj !== 'object') {\n        return callback(new Error(\"No data to save\"));\n      }\n\n      this.node._create(obj, callback);\n    } else {\n      if (val) this.node._updateProp(obj, key, val, callback);\n      else this.node._update(obj, callback);\n    }\n  },\n\n  /**\n   * Create a new object. Maps to /node.\n   */\n  _create: function(obj, callback) {\n    var op = this.operation('node', obj);\n    this.call(op, function(err, body, location) {\n      if (err) {\n        return callback(err);\n      }\n\n      var result = _.clone(obj);\n      result[this.options.id] = this._extractId(location);\n\n      callback(null, result);\n    });\n  },\n\n  /**\n   * Save the properties of an object. Maps to PUT /node/{id}/properties.\n   */\n  _update: function(obj, callback) {\n    var id = this._getId(obj, true);\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var untouchedObj = _.clone(obj);\n    if (untouchedObj[this.options.id] != null) {\n      delete untouchedObj[this.options.id];\n    }\n\n    var endpoint = util.format('%s/properties', this._nodeRoot(id));\n    var op = this.operation(endpoint, 'PUT', untouchedObj);\n    this.call(op, function(err, body, response) {\n      if (err) {\n        return callback(err);\n      } else {\n        return callback(null, obj);\n      }\n    });\n  },\n\n  _updateProp: function(obj, key, val, callback) {\n    var id = this._getId(obj);\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var endpoint = util.format('%s/properties/%s', this._nodeRoot(id), key);\n    var op = this.operation(endpoint, 'PUT', val);\n    this.call(op, function(err, body) {\n      if (err) return callback(err);\n      else {\n        obj = _.clone(obj);\n        obj[key] = val;\n        callback(null, obj);\n      }\n    });\n  },\n\n  /**\n   * Read an object's properties. Maps to GET node/{id}/properties.\n   */\n  read: function(id, property, callback) {\n    if (typeof property == 'function') {\n      callback = property;\n      property = null;\n    }\n\n    if (Array.isArray(id)) {\n      var txn = this._safeBatch();\n      async.map(id, naan.ncurry(txn.read, property, 1), callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    id = this._getId(id);\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var endpoint;\n    if (!property) \n      endpoint = util.format('%s/properties', this._nodeRoot(id));\n    else\n      endpoint = util.format('%s/properties/%s', this._nodeRoot(id), property);\n    var op = this.operation(endpoint);\n    this.call(op, function(err, body) {\n      if (err) {\n        return callback(err);\n      } else {\n        if (!property) body[this.options.id] = id;\n        return callback(null, body);\n      }\n    });\n  },\n\n  /**\n   * Delete an object. Maps to DELETE node/{id}\n   * If force is truthy, delete node and all its relations.\n   */\n  delete: function(id, force, callback) {\n    var property = null;\n    if (typeof force == 'function') {\n      callback = force;\n      force = false;\n    } else if (typeof force == 'string') {\n      property = force;\n      force = false;\n    }\n\n    if (Array.isArray(id)) {\n      var txn = this._safeBatch();\n      async.map(id, naan.ncurry(txn.node.delete, force || property, 1), callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    var object = id;\n    id = this._getId(id);\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    if (!force) {\n      var endpoint;\n      if (!property) endpoint = this._nodeRoot(id);\n      else\n        endpoint = util.format('%s/properties/%s', this._nodeRoot(id), property);\n      var op = this.operation(endpoint, 'DELETE');\n      this.call(op, function(err) { \n        if (!property || err || typeof object != 'object') callback(err);\n        else {\n          delete object[property];\n          callback(null, object);\n        }\n      });\n    } else {\n      this.query([\n        'START node=node({root})',\n        'OPTIONAL MATCH (node)-[rel]-()',\n        'DELETE node, rel'\n      ].join(' '), {root: id}, function(err) { callback(err) });\n    }\n  },\n\n  /**\n   * Relate objects together. maps to POST node/{first}/relationships\n   */\n  relate: function(startNode, type, endNode, properties, callback) {\n    this.rel.create(startNode, type, endNode, properties, callback);\n  },\n\n  /**\n   * Retrieve a set of relationships for the given node. Optionally specify the\n   * direction and relationship name.\n   *\n   * `direction` must be one of \"all\", \"in\" or \"out\".\n   *\n   * db.relationships(obj|id, [direction, [relationshipName]], callback)\n   */\n  relationships: function(obj, direction, relName, callback) {\n    if (typeof direction === 'function') {\n      callback = direction;\n      direction = 'all';\n      relName = '';\n    } else {\n      if (typeof relName === 'function') {\n        callback = relName;\n        relName = '';\n      }\n\n      if (typeof direction !== 'string') {\n        return callback(new Error('Invalid direction - ' + direction));\n      } else if (typeof relName !== 'string') {\n        return callback(new Error('Invalid relationship name - ' + relName));\n      }\n\n      direction = direction.toLowerCase();\n      if (['in', 'all', 'out'].indexOf(direction) === -1) {\n        return callback(new Error('Invalid direction - ' + direction));\n      }\n    }\n\n    if (Array.isArray(obj)) {\n      var txn = this._safeBatch();\n      var args = [ direction, relName ];\n      var rels = naan.ecurry(txn.node.relationships, args, [1, 2]);\n      async.map(obj, rels, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    var objId = this._getId(obj);\n\n    if (!this._isValidId(objId)) {\n      callback(new Error(\"Invalid ID\"));\n    }\n\n    var nodeRoot = this._nodeRoot(objId);\n    var endpoint = util.format('%s/relationships/%s', nodeRoot, direction);\n    if (relName) {\n      endpoint += \"/\" + relName;\n    }\n    var op = this.operation(endpoint);\n    var self = this;\n    this.call(op, function(err, rels) {\n      if (err) {\n        callback(err);\n      } else {\n        rels = rels.map(function(rel) {\n          return self._createRelationshipObject(rel);\n        });\n        callback(null, rels);\n      }\n    });\n  },\n\n  /**\n   * Perform a query based on a predicate. The predicate is translated to a\n   * cypher query.\n   */\n  find: function(predicate, any, label, callback) {\n    if (typeof any == 'function') {\n      callback = any;\n      any = false;\n      label = null;\n    } else if (typeof label == 'function') {\n      callback = label;\n      if (typeof any == 'string') {\n        label = any;\n        any = false;\n      } else {\n        label = null;\n      }\n    } \n    \n    if (Array.isArray(predicate)) {\n      var txn = this._safeBatch();\n      var finder = naan.ecurry(txn.node.find, [any, label], [1, 2]);\n      async.map(predicate, finder, callback);\n      return this._safeBatchCommit(txn);\n    } \n\n    if (typeof predicate !== 'object') callback(new Error('Invalid Predicate'));\n\n    var matchers = Object.keys(predicate).reduce(function(matchers, key) {\n      return matchers.push(util.format(\"n.%s = {%s}\", key, key)), matchers;\n    }, []);\n\n    var cypher = [ \n      label == null ? \"MATCH (n)\" : util.format(\"MATCH (n:`%s`)\", label),\n      matchers.length > 0 ? \"WHERE\" : \"\",\n      matchers.join(any ? \" or \" : \" and \"), \n      \"RETURN n\"\n    ].join(\" \");\n\n    this.query(cypher, predicate, callback);\n  },\n\n  label: function(node, label, replace, callback) {\n    if (typeof replace == 'function') {\n      callback = replace;\n      replace = false;\n    }\n\n    if (Array.isArray(node)) {\n      var txn = this._safeBatch();\n      async.map(node, naan.ecurry(txn.label, [label, replace], [1,2]), callback);\n      return this._safeBatchCommit(txn);\n    }\n    \n    var id = this._getId(node);\n    if (!this._isValidId(id)) return callback(new Error(\"Invalid ID\"));\n\n    var endpoint = util.format('%s/labels', this._nodeRoot(id));\n    var op = this.operation(endpoint, replace ? 'PUT' : 'POST', label);\n    this.call(op, function(err) {\n      if (err) callback(err);\n      else callback();\n    });\n  },\n\n  removeLabel: function(node, label, callback) {\n    if (Array.isArray(node)) {\n      var txn = this._safeBatch();\n      async.map(node, naan.ncurry(txn.removeLabel, label, 1), callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    var id = this._getId(node);\n    if (!this._isValidId(id)) return callback(new Error(\"Invalid ID\"));\n\n    var endpoint = util.format('%s/labels/%s', this._nodeRoot(id), label);\n    var op = this.operation(endpoint, 'DELETE');\n    this.call(op, function(err) {\n      if (err) callback(err);\n      else callback();\n    });\n  },\n\n  nodesWithLabel: function(label, callback) {\n    var endpoint = util.format('label/%s/nodes', label);\n    var op = this.operation(endpoint, 'GET');\n    this.call(op, function(err, nodes) {\n      if (err || !nodes) return callback(err, nodes);\n      nodes = nodes.map(this._createNodeObject);\n      callback(null, nodes);\n    });\n  },\n\n  readLabels: function(node, callback) {\n    if (typeof node == 'function') {\n      callback = node;\n      node = undefined;\n    }\n\n    if (Array.isArray(node)) {\n      var txn = this._safeBatch();\n      async.map(node, txn.readLabels, function(err, allLabels) {\n        if (err) return callback(err);\n        callback(null, _.uniq(_.flatten(allLabels)));\n      });\n      return this._safeBatchCommit(txn);\n    }\n\n    var endpoint;\n    if (node) {\n      var id = this._getId(node);\n      if (!this._isValidId(id)) return callback(new Error(\"Invalid ID\"));\n      endpoint = util.format('%s/labels', this._nodeRoot(id));\n    } else {\n      endpoint = 'labels';\n    }\n    var op = this.operation(endpoint, 'GET');\n    this.call(op, function(err, labels) {\n      if (err) callback(err);\n      else callback(null, labels);\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-seraph/node_modules/seraph/lib/relationship.js":"var async = require('async');\nvar naan = require('naan');\nvar _ = require('underscore');\nvar util = require('util');\n\nmodule.exports = {\n  /**\n   * Create a new relationship between two nodes. Maps to \n   * POST node/<startNodeId>/relationship\n   */\n  create: function(startNode, type, endNode, properties, callback) {\n    if (typeof properties === 'function') {\n      callback = properties;\n      properties = null;\n    }\n\n    if (Array.isArray(startNode)) {\n      var txn = this._safeBatch();\n      var args = [ type, endNode, properties ];\n      async.map(startNode, naan.ecurry(txn.rel.create, args, [1,2,3]), \n          function(err, rels) {\n            if (!err && Array.isArray(endNode))\n              return callback(err, _.flatten(rels));\n            callback(err, rels);\n          });\n      return this._safeBatchCommit(txn);\n    } else if (Array.isArray(endNode)) {\n      var txn = this._safeBatch();\n      var args = [ startNode, type, properties ];\n      async.map(endNode, naan.ecurry(txn.rel.create, args, [0,1,3]), callback);\n      return this._safeBatchCommit(txn);\n    }\n    \n    var startNodeId = this._getId(startNode),\n        endNodeId = this._getId(endNode);\n\n    if (!this._isValidId(startNodeId) ||\n        !this._isValidId(endNodeId)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var request = {\n      to: this._location('node', endNodeId),\n      type: type,\n    };\n\n    if (properties) {\n      request['data'] = properties;\n    }\n\n    var endpoint = util.format('%s/relationships', this._nodeRoot(startNodeId));\n    var op = this.operation(endpoint, 'POST', request);\n    this.call(op, function(err, rel) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, this._createRelationshipObject(rel));\n      }\n    });\n  },\n\n  /**\n   * Update the properties of a given relationship. Maps to\n   * PUT relationship/<id>/properties\n   */\n  update: function(rel, key, val, callback) {\n    if (typeof key == 'function') {\n      callback = key;\n      key = val = undefined;\n    }\n\n    if (Array.isArray(rel)) {\n      var txn = this._safeBatch();\n      var args = [key, val];\n      async.map(rel, naan.ecurry(txn.rel.update, args, [1, 2]), callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    var id = this._getId(rel);\n\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var endpoint = util.format('%s/properties', this._relRoot(id));\n    if (key) endpoint += '/' + key;\n\n    var op = this.operation(endpoint, 'PUT', key ? val : rel.properties);\n    this.call(op, function(err) {\n      callback(err);\n    });\n  }, \n\n  read: function(id, callback) {\n    if (Array.isArray(id)) {\n      var txn = this._safeBatch();\n      async.map(id, txn.rel.read, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    id = this._getId(id);\n\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var endpoint = this._relRoot(id);\n    var op = this.operation(endpoint);\n    this.call(op, function(err, rel) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, this._createRelationshipObject(rel));\n      }\n    });\n  },\n\n  delete: function(id, callback) {\n    if (Array.isArray(id)) {\n      var txn = this._safeBatch();\n      async.map(id, txn.rel.delete, callback);\n      return this._safeBatchCommit(txn);\n    }\n\n    id = this._getId(id);\n\n    if (!this._isValidId(id)) {\n      return callback(new Error(\"Invalid ID\"));\n    }\n\n    var endpoint = this._relRoot(id);\n    var op = this.operation(endpoint, 'DELETE');\n    this.call(op, function(err, rel) {\n      callback(err);\n    });\n  }\n};\n"}